

#include "leetcode.h"

#include "List.h"
#include "tstList.h"


//#define GOOGLE_STRIP_LOG 1
#include <glog/logging.h>
#define GOOGLE_STRIP_LOG 1



//#define LOG_TRACE LOG(INFO)
//#define LOG_DEBUG LOG(INFO)
#define LOG_INFOEX   LOG(INFO)
//#define GDLOG_TRACEEX LOG(INFO) << __PRETTY_FUNCTION__ << " this=" << this << " "
//#else

extern int tst_rand();
extern int tst_rand(int low, int high);


extern BstNode* g_pBstTree;


/* --------------------------------------------------------------------------
 1. Convert Sorted Array to Binary Search Tree
 2. Convert Sorted List to Binary Search Tree

 * --------------------------------------------------------------------------*/


void Test_C11Random() {
    std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_int_distribution<> distrib(1, 6);
 
    for (int n=0; n<10; ++n)
        //Use `distrib` to transform the random unsigned int generated by gen into an int in [1, 6]
        std::cout << distrib(gen) << ' ';
    std::cout << '\n';
}


// Convert Sorted Array to Binary Search Tree
// Given an array where elements are sorted in ascending order, convert it to a height balanced BST.
// 思路：
// 给定一个区间[left, right]，取其中值mid=(left+right)/2对应的元素作为二叉树的根。二叉树的左子树根的值为对[left, mid-1]继续操作的结果，右子树类似。

void someInOrder(TreeNode* root);
void InOrtderPtrint(TreeNode* root);

//class Solution {
//public:
TreeNode *generateBST(int left, int right, std::vector<int> &vec)
{
    if (left > right)
    {
        return nullptr;
    }
    else if (left == right)
    {
        return new TreeNode(vec[left]);
    }
    else
    {
        int mid1 = (left + right) >> 1;
//            printf("mid1=%d\n", mid1);

        TreeNode *newnode = new TreeNode(vec[mid1]);
        newnode->left = generateBST(0, mid1 - 1, vec);
        newnode->right = generateBST(mid1 + 1, right, vec);
        return newnode;
    }
}
TreeNode *sortedArrayToBst(std::vector<int> &vec)
{
    return generateBST(0, vec.size() - 1, vec);
}
void InOrtderPtrint(TreeNode *root)
{
    std::cout << std::endl;
    someInOrder(root);
    std::cout << std::endl;
}
void someInOrder(TreeNode *root)
{
    if (!root)
    {
        printf("root is null\n");
        return;
    }
    if (root->left)
        someInOrder(root->left);
    std::cout << root->val << '\t';
    if (root->right)
        someInOrder(root->right);
}

std::vector<ListNode *> ConstructTestListByParam(int start, int end, int numCount, int listCount)
{
    std::vector<ListNode *> arrays;
    // ----------------
    time_t t;
    srand(time(&t));
    for (int i = 0; i < listCount; i++)
    {

        std::vector<int> tmpArr;
        for (int j = 0; j < numCount; j++)
        {
            tmpArr.push_back(tst_rand(start, end));
        }
        arrays.push_back(ConstructList(tmpArr));
    }
    // ----------------
    return arrays;
}

// Convert Sorted List to Binary Search Tree -- LeetCode 将有序链表转为二叉搜索树
class CSortedListToBst {
public:

    ListNode* reverseList( ListNode* pHead ) {
        if (!pHead) return nullptr;
        {
            ListNode* prePtr = nullptr, *curPtr = pHead, *nextPtr = curPtr->next;
            while (nextPtr) {
                curPtr->next = prePtr;
                prePtr = curPtr;

                curPtr = nextPtr;
                nextPtr = nextPtr->next;
            }
            curPtr->next = prePtr;
            return curPtr;
        }

        ListNode* prePtr = nullptr, *curPtr = pHead, *nextPtr = curPtr->next;
        while (nextPtr) {
            curPtr->next = prePtr;
            prePtr = curPtr;

            curPtr = nextPtr;
            nextPtr = nextPtr->next;
        }
        curPtr->next = prePtr;
        return curPtr;
    }



    void TstEntry() {
        std::vector<int> l{11, 23, 36, 47, 51, 53, 198, 2739, 31798};
        auto headList = ConstructList(l);

        TreeNode* root = SortedListToBst(headList);
        PrintList(headList);

        std::cout << std::endl << std::endl
                  << " in order print tree beg---------" << std::endl;
        someInOrder(root);
        std::cout << std::endl
                  << " in order print tree end---------" << std::endl;
    }
    TreeNode* SortedListToBst(ListNode* head) {
        if (!head) return nullptr;
        helper(head, nullptr);
    }
    TreeNode* helper(ListNode* head, ListNode* tail) {
        if (head == tail) return nullptr;

        ListNode* slow = head, *fast = head;
//        std::cout << "slow=" << slow <<std::endl;
//        std::cout << "fast=" << fast <<std::endl;

        while (fast != tail && fast->next != tail) {
            slow = slow->next;
            fast = fast->next->next;
        }
//        std::cout << "slow->val=" << slow->val << std::endl;
//        std::cout << "fast->val=" << fast->val << std::endl;
//        return nullptr;

        TreeNode* root = new TreeNode(slow->val);
        root->left = helper(head, slow);
        root->right = helper(slow->next, tail);
        return root;
    }

};

void TstList1()
{
    std::vector<int> l{11, 23, 35, 47, 51, 53, 198, 2739, 31798};
    ListNode *headL = ConstructList(l);
    PrintList(headL);

    // CSortedListToBst listObj;
    // listObj.TstList1();

    // ListNode* pReverseList = reverseList( pNode1 );
    // PrintList(pReverseList);
}

// Given preorder and inorder traversal of a tree, construct the binary tree.
// Note:
// You may assume that duplicates do not exist in the tree.

// For example, given
// preorder = [3,9,20,15,7]
// inorder  = [9,3,15,20,7]

// Return the following binary tree:

/*
    3
   / \
    9  20
    /  \
   15   7
*/
/*
 *
 *  首先要知道一个结论，前序/后序+中序序列可以唯一确定一棵二叉树，所以自然而然可以用来建树。
 *  看一下前序和中序有什么特点，前序1,2,4,7,3,5,6,8 ，中序4,7,2,1,5,3,8,6；
 *
 *  有如下特征：
 *
 *  1. 前序中左起第一位1肯定是根结点，我们可以据此找到中序中根结点的位置rootin；
 *  2. 中序中根结点左边就是左子树结点，右边就是右子树结点，即[左子树结点，根结点，右子树结点]，
 *     我们就可以得出左子树结点个数为int left = rootin - leftin;；
 *  3. 前序中结点分布应该是：[根结点，左子树结点，右子树结点]；
 *  4. 根据前一步确定的左子树个数，可以确定前序中左子树结点和右子树结点的范围；
 *  5. 如果我们要前序遍历生成二叉树的话，下一层递归应该是：
 *      左子树：root->left = pre_order(前序左子树范围，中序左子树范围，前序序列，中序序列);；
 *      右子树：root->right = pre_order(前序右子树范围，中序右子树范围，前序序列，中序序列);。
 *  6. 每一层递归都要返回当前根结点root；
 */

class CBuildBstByPreInorder {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int pos = 0;
        return buildTree(preorder, pos, inorder, 0, preorder.size() - 1);
    }

    TreeNode* buildTree(vector<int>& preorder, int& pos, vector<int>& inorder, int left, int right) {
        if (pos >= preorder.size()) return 0;
        int i = left;
        for (; i <= right; ++i) {
            if (inorder[i] == preorder[pos]) break;
        }
        TreeNode* newNode = new TreeNode(preorder[pos]);
        if (left <= i-1)  newNode->left  = buildTree(preorder, ++pos, inorder, left, i-1);  // 左子树
        if (i+1 <= right) newNode->right = buildTree(preorder, ++pos, inorder, i + 1, right);  // 右子树
        return newNode;
    }

    void WorkEntry() {
        std::vector < int > preOrder = {3,9,20,15,7};
        std::vector < int > inOrder  = {9,3,15,20,7};
        TreeNode* root = buildTree(preOrder, inOrder);
        InOrtderPtrint(root);
    }
};




    void tst_1_lc() {
        std::vector<int> vecArr{ -10,-3,0,5,9};
        TreeNode* root = sortedArrayToBst(vecArr);
        std::cout << std::endl;
        someInOrder(root);
        std::cout << std::endl;
    }


    int sort_desc(vector<int>& nums, int left, int right, int k) {
        int pivot = nums[ left ];
        int i = left;
        int j = right;
        int res = 0;

        while ( i < j ) {
            while ( i < j && nums[ j ] <= pivot ) j --;
            while ( i < j && nums[ i ] >= pivot ) i ++;
            if ( i < j ) swap(nums[i], nums[j]);
        }
        std::swap(nums[left], nums[i]);

        if ( i + 1 == k ) return nums[ i ];
        else if ( i + 1 > k ) res = sort_desc(nums, left, i - 1, k);
        else if ( i + 1 < k ) res = sort_desc(nums, i + 1, right, k);
        return res;
    }

    // LeetCode 215. Kth Largest Element in an Array--数字第K大的元素
    // 从大到小排列；
    int findKthLargest(vector<int>& nums, int k) {

        // int l = 0, r = nums.size() - 1;
        // while (1) {
        //     int pos = partition(nums, l, r);
            
        //     if ( pos == k-1 ) return nums[ k - 1 ];

        //     if ( pos > k-1 ) {
        //         r = pos - 1;
        //     }
        //     else {
        //         l = pos + 1;
        //     }
        // }
        return 1;
    }

    /*
        上面两种方法虽然简洁，但是确不是本题真正想考察的东西，可以说有一定的偷懒嫌疑。
        这道题最好的解法应该是下面这种做法，用到了快速排序 Quick Sort 的思想，
        这里排序的方向是从大往小排。
        核心思想是每次都要先找一个中枢点 Pivot，然后遍历其他所有的数字，像这道题从大往小排的话，
        就把大于中枢点的数字放到左半边，把小于中枢点的放在右半边，这样中枢点是整个数组中第几大的数字就确定了，
        虽然左右两部分各自不一定是完全有序的，但是并不影响本题要求的结果，
        因为左半部分的所有值都大于右半部分的任意值，所以我们求出中枢点的位置，
        如果正好是 k-1，那么直接返回该位置上的数字；
        如果大于 k-1，说明要求的数字在左半部分，更新右边界，再求新的中枢点位置；
        反之则更新右半部分，求中枢点的位置；
    */
    void tst_KthBig() { // 数组中第k大的数字
        std::vector < int > vRandom =
             { 9, 1, 123, 6613, 31, 25, 123, -333,  72,  19, 9981, 33812, -17 };
        int idx = 3;

        auto retVal = sort_desc(vRandom, 0, vRandom.size() - 1, idx);
        // auto retVect = findKthLargest( vRandom, idx );
        // PrintInContainer(retVect);
        std::cout << "idx=" << idx << ", Max Val Kth=" << retVal << std::endl;
        return;

{// -333 -17 1 9 19 25 31 72 123 123 6613 9981 33812
        // std::priority_queue<int, std::vector<int>, greater<int>> que(vRandom.begin(), vRandom.end());
        // for (size_t i = 0; i < vRandom.size(); ++i) {
        //     std::cout << " " << que.top() ;
        //     que.pop();
        // }
        // std::cout << std::endl;
        // return;
}
{ // the newest work code ---- 大顶堆方式
// 33812 9981 6613 123 123 72 31 25 19 9 1 -17 -333
        priority_queue<int> q(vRandom.begin(), vRandom.end());
        for (size_t i = 0; i < (size_t)(idx - 1); ++i) {
            std::cout << " pop=" << q.top() ;
            q.pop();
        }
        std::cout << std::endl;
        std::cout << "idx=" << idx << ", Max Val Kth=" << q.top() << std::endl;
        return;
}

    }

// 
void Test_KthLeastNumbers() {
    int k = 5;
    std::vector<int> arr { 1, 7, 123, -333, -4236, -33391,  72,  19, 9981, 33812, -17 };
{
        priority_queue<int, vector<int>, greater<int>> smallqueue;
        vector<int> result;

        for (size_t i = 0; i < arr.size(); i++) {
            smallqueue.push(arr[i]);
        }
        
    // PrintInPriorQue(smallqueue);
    //     return;

        int n = 0;
        while (n < k && !smallqueue.empty()) {
            result.push_back(smallqueue.top());
            smallqueue.pop();
            n++;
        }

        PrintInContainer(result);
        return;
}
    std::priority_queue<int, std::vector<int>> que;
    // std::priority_queue<int, vector<int>, greater<int>> smallqueue;

    for ( auto ele : arr ) {

        if (que.size() < k) {
            que.push(ele);
        } else {
            que.push(ele);
            que.pop();
        }

    }

    while ( !que.empty() ) {
        auto ele = que.top();
        que.pop();
        std::cout << " " << ele;
    }
        std::cout << std::endl;

}



/*
 * 根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。
 * 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。
 * 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。
 * // https://leetcode-cn.com/problems/daily-temperatures/solution/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/
*/
std::vector<int> dailyTemperatures(std::vector<int>& temperatures) {
    int n = temperatures.size();
    std::vector<int> res(n, 0);
    std::stack<int> st;
    for (size_t i = 0; i < temperatures.size(); ++i) {
        while (!st.empty() && temperatures[i] > temperatures[st.top()]) {
            auto t = st.top(); st.pop();
            res[t] = i - t;
        }
        st.push(i);
    }
    return res;
}


/*
        给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。

        示例:

        输入: 3
        输出:
        [
          [1,null,3,2],
          [3,2,null,1],
          [3,1,null,null,2],
          [2,1,3],
          [1,null,2,null,3]
        ]

        解释:
        以上的输出对应以下 5 种不同结构的二叉搜索树：

           1         3     3      2      1
            \       /     /      / \      \
             3     2     1      1   3      2
            /     /       \                 \
           2     1         2                 3
*/

class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 2, 0);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; ++i) {
            for (int j = 0; j < i; ++j) {
                dp[i] += dp[j] * dp[i - j - 1];
            }
        }
        return dp[n];
    }
};




/*
    思路一：中心扩散
    从开始每个字符进行判断，回文串字符个数可能为奇数或偶数

    如果是奇数，则中心字符为当前字符，然后向两边扩散
    如果是偶数，则中心字符为当前字符和下一个字符，然后向两边扩散
*/
class CheckHuiWen
{
public:
    void IsHuiWen() {
        std::string str = "abtx21ba";

        int sum = 0;
        for (size_t i = 0; i < str.size(); ++ i) {
            sum += helper(str, i, i);
            sum += helper(str, i, i+1);
        }
        std::cout << "sum=" << sum << std::endl;
        std::cout << "str.size=" << str.size() << std::endl;
    }

    int helper(std::string& str, size_t i, size_t j) {
        int sum = 0;
        if (i >= 0 && j < str.size() && str[i] == str[j]) {
            --i, j++, sum++;
        }
        return sum;
    }
};


/*
    给定一个二叉树，判断它是否是高度平衡的二叉树。

    本题中，一棵高度平衡二叉树定义为：

    一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

    示例 1:

    给定二叉树 [3,9,20,null,null,15,7]

        3
       / \
      9  20
        /  \
       15   7
    返回 true

    示例 2:

    给定二叉树 [1,2,2,3,3,null,null,4,4]

           1
          / \
         2   2
        / \
       3   3
      / \
     4   4
    返回 false
*/

int Depth(BstNode* root) {
    if (!root) return 0;
    return std::max(Depth(root->left), Depth(root->right)) + 1;
}
bool isBalanced(BstNode* root) {
    if (!root) return true;
    int gap = std::abs(Depth(root->left) - Depth(root->right));
    return (gap <= 1 && isBalanced(root->left) && isBalanced(root->right));
}

/*
        Leetcode 98. 验证二叉搜索树
        给定一个二叉树，判断其是否是一个有效的二叉搜索树。

        二叉搜索树具有如下特征：
        节点的左子树只包含小于当前节点的数。
        节点的右子树只包含大于当前节点的数。
        所有左子树和右子树自身必须也是二叉搜索树。

        示例 1:
        输入:
            2
           / \
          1   3
        输出: true

        示例 2:
        输入:
            5
           / \
          1   4
             / \
            3   6
        输出: false
        解释: 输入为: [5,1,4,null,null,3,6]。
             根节点的值为 5 ，但是其右子节点值为 4 。
*/
class CheckIfBst {
public:
//    bool IsValidBst(BstNode* root) {
//        if (!root) return true;
//        return IsLeftBst(root->left, root->val) && IsRightBst(root->right, root->val);
//    }
//    bool IsLeftBst(BstNode* root, int val) {
//        if (IsValidBst(root)) {
//            while (root) {
//                if (root->val >= val) return fasle;
//                root = root->right;
//            }
//            return true;
//        } else {
//            return false;
//        }
//    }
//    bool IsRightBst(BstNode* root, int val) {
//        if (IsValidBst(root)) {

//        }
//    }

    bool IsValidBst_1(BstNode* root) {
        UNUSED(root);
//        std::vector<int> arrVal;
//        inorder(root, arrVal);
//        for (size_t i = 0; i < arrVal.size(); i++) {
//            if (arrVal[i] <= arrVal[i-1]) return false;
//        }
        return true;
    }
    void inorder(BstNode* root, std::vector<int>& arrVal) {
        UNUSED(root);
        UNUSED(arrVal);
//        if (!root) return;
//        inorder(root->left, arrVal);
//        arrVal.push_back(root->val);
//        inorder(root->right, arrVal);
    }

};



#define DISABLE_COPY(ClassName) \
    ClassName(const ClassName&) = delete;
#define DISABLE_ASSIGN(ClassName) \
    ClassName& operator=(const ClassName&) = delete;


class ObjA
{
//public:
    DISABLE_COPY(ObjA)
    DISABLE_ASSIGN(ObjA)
public:
    ObjA() {

    }
public:
    void PrintSomeInfo() {
        std::cout << "val ---- " << std::endl;
    }
    static ObjA* GetInstance() {
        return (new ObjA);
    }
};

/**
 * 二分查找
 * @param n int整型 数组长度
 * @param v int整型 查找值
 * @param a int整型vector 有序数组
 * @return int整型
 */
int upper_bound_(int n, int v, vector<int>& a) {
    int left = 0, right = n - 1;
    int mid = 0;
    while ( left < right ) {
        mid = (left + right) >> 1;
//        sleep(1);
//        std::cout << "mid=" << mid  << std::endl;
//        if (a[mid] < v) {
//            right = mid + 1;
//        } else {
//            right = mid;
//        }
        if ( a[ mid ] >= v ) {
            if ( mid == 0 || a[mid - 1] < v ) {
                return mid/* + 1*/;
            }
            else {
                right = mid;
            }
        } else {
            left = mid + 1;
        }
    }
    return n + 1;
}

void tstupper_bound() {
    std::vector<int> a{1, 2, 3, 4, 4, 5};
    std::cout << upper_bound_(a.size(), 4, a) << std::endl;
}


/*
    461. 汉明距离
两个整数之间的汉明距离, 指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 x 和 y，计算它们之间的汉明距离。

注意： 0 ≤ x, y < 231.

示例: 输入: x = 1, y = 4
输出: 2
解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。
*/
int hammingDistance(int x, int y) {
    int xorRes = x ^ y;
    int count  = 0;
    while (xorRes > 0) {
        if (1 == (xorRes & 1)) {
            count++;
        }
        xorRes = xorRes >> 1;
    }
    return count;
}
void Test_hanmingDistance() {
    auto ret = hammingDistance(1, 22);
    std::cout << "result=" << ret << std::endl;
}


/*
    226. 翻转二叉树
示例：
输入：
     4
   /   \
  2     7
 / \   / \
1   3 6   9
输出：
     4
   /   \
  7     2
 / \   / \
9   6 3   1
备注:
这个问题是受到 Max Howell 的 原问题 启发的 ：
谷歌：我们90％的工程师使用您编写的软件(Homebrew)，
但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。
*/
BstNode* invertTree(BstNode* root) {
    if (!root) return nullptr;
    BstNode* left  = invertTree(root->left);
    BstNode* right = invertTree(root->right);
    root->left = right;
    root->right = left;
    return root;
}
void Test_invertTree() {

    PrintInorder(g_pBstTree);
    
    invertTree(g_pBstTree);
    
    PrintInorder(g_pBstTree);
}

/*
    104. 二叉树的最大深度

*/



/*
    222.二叉树的节点个数/二叉树：有多少个节点
    给出一个二叉树，求出该树的节点个数。
*/
int countNodes(BstNode* cur) {
    if (!cur) return 0;
    return 1 + countNodes(cur->left) + countNodes(cur->right);
}
void Test_getNodesNum() {
    PrintInorder(g_pBstTree);

    int kNums = countNodes(g_pBstTree);
    std::cout << "kNums=" << kNums << std::endl;
}

/*
    111.二叉树的最小深度
    给定一个二叉树，找出其最小深度。

    最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

    说明: 叶子节点是指没有子节点的节点。
    示例 1：
    输入：root = [3,9,20,null,null,15,7]
    输出：2

    示例 2：
    输入：root = [2,null,3,null,4,null,5,null,6]
    输出：5
*/
int minDepth(TreeNode *root)
{
    if (!root) return 0;

    int lmin = minDepth(root->left);
    int rmin = minDepth(root->right);
    if (!lmin && !rmin)
        return 1;
    if (!lmin || !rmin)
        return (lmin + rmin + 1);
    return (std::min(lmin, rmin) + 1);
}
void Test_minDepth() {
}

/*
257. 二叉树的所有路径
给定一个二叉树，返回所有从根节点到叶子节点的路径。

说明: 叶子节点是指没有子节点的节点。

示例: 输入
   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
*/
void traversal(BstNode* cur, string path, vector<string>& result) {
    path += to_string(cur->val);
    if (!cur->left && !cur->right) {
        result.push_back(path);
        return;
    }
    if (cur->left) {
        traversal(cur->left, path + "->", result);
    }
    if (cur->right) {
        traversal(cur->right, path + "->", result);
    }
}
vector<string> binaryTreePaths(BstNode *root) {
    std::vector<string> result;
    std::string path;
    if (!root) return result;

    traversal(root, path, result);
    return result;
}
void Test_binaryTreePaths() {
    std::cout << "before handle ..." << std::endl;
    PrintInorder(g_pBstTree);
    std::cout << std::endl;

    auto paths = binaryTreePaths(g_pBstTree);
    PrintInContainer(paths);
}

/*
404. 左叶子之和
计算给定二叉树的所有左叶子之和。
示例：
    3
   / \
  9  20
    /  \
   15   7
在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24

「首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。」

左叶子的定义：「如果左节点不为空，且左节点没有左右孩子，那么这个节点就是左叶子」

------------------------ 提示 ------------------------
如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶子，判断代码如下：

if (node->left != NULL && node->left->left == NULL && node->left->right == NULL) {
    左叶子节点处理逻辑
}
*/
int sumOfLeftLeaves(BstNode *root) {
    if (!root) return 0;
    int res = 0;
    if (root->left && root->left->left == nullptr && root->left->right) {
        res = root->left->val;
    }
    return res + sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);
}
void Test_sumOfLeftLeaves() {
    std::cout << "before handle ..." << std::endl;
    PrintInorder(g_pBstTree);
    std::cout << std::endl;

    std::cout << "sum=" << sumOfLeftLeaves(g_pBstTree) << std::endl;
}

/*
    513. 找树左下角的值
    一个二叉树，在树的最后一行找到最左边的值。

示例 1:
输入:
    2
   / \
  1   3
输出: 1

示例 2:
输入:
        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7
输出: 7

-----------------------------------------------------------------------
如果需要搜索整颗二叉树，那么递归函数就不要返回值。
如果需要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径，就要及时返回。
-----------------------------------------------------------------------
*/
class CFindLeftMinVal {
    int maxLeftVal = INT_MIN;
    int maxDepth   = INT_MIN;

void traversal_for_leftTree(BstNode *root, int tmpDepth)
{
    if (nullptr == root->left && nullptr == root->right) {
        if (tmpDepth > maxDepth) {
            maxLeftVal = root->val;
            maxDepth = tmpDepth;
            return;
        }
    }
    if (root->left)  traversal_for_leftTree(root->left, tmpDepth + 1);
    if (root->right) traversal_for_leftTree(root->right, tmpDepth + 1);
}
public:
    int findBottomLeftValue(BstNode *root) {
        traversal_for_leftTree(root, 0);
        return maxLeftVal;
    }
};

/*
112. 路径总和
给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例: 给定如下二叉树，以及目标和 sum = 22，
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2

-----------------------------------------------------------------------
复杂度分析：

时间复杂度： O(N)，其中 NN 是树的节点数。对每个节点访问一次。
空间复杂度： O(H)，其中 HH 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 O(logN)。
-----------------------------------------------------------------------
*/
bool hasPathSum(BstNode *root, int sum) {
    if (!root)
        return false;
    if (root->left == nullptr && root->right == nullptr) {
        return sum == root->val;
    }
    return hasPathSum(root->left, sum - root->val) && hasPathSum(root->right, sum - root->val);
}
void Test_hasPathSum() {
    bool bret = hasPathSum(g_pBstTree, 100);
    std::cout << "bret=" << bret << std::endl;
}

/*
        113. 路径总和 II
给定一个二叉树和一个目标和，找到 `所有` 从根节点到叶子节点 路径总和 等于给定目标和的路径。

说明: 叶子节点是指没有子节点的节点。

示例: 给定如下二叉树，以及目标和 sum = 22，
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
返回:
[
   [5,4,11,2],
   [5,8,4,5]
]

-----------------------------------------------------------------------
注意到本题的要求是，找到所有满足从「根节点」到某个「叶子节点」经过的路径上的节点之和等于目标和的路径。核心思想是对树进行一次遍历，在遍历时记录从根节点到当前节点的路径和，以防止重复计算。
-----------------------------------------------------------------------
*/
class CFindAllPaths {
    std::vector< std::vector<int> > res_;
    std::vector<int> tmp_;

    void preorder_traversal(BstNode *root, int sum) {
        if (!root) return;

        sum -= root->val;
        tmp_.push_back(root->val);

        if (nullptr == root->left && nullptr == root->right && sum == 0) {
            res_.push_back(tmp_);
        }

        preorder_traversal(root->left, sum);
        preorder_traversal(root->right, sum);
        tmp_.pop_back();
    }
public:
    void pathSum(BstNode *root, int sum) {
        if (!root) return;
        preorder_traversal(root, sum);
    }
};


/*
    477. 汉明距离总和
两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。

计算一个数组中，任意两个数之间汉明距离的总和。

示例:
输入: 4, 14, 2
输出: 6

解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）
答案：
4   0100
14  1110
2   0010
HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6
*/
int totalHammingDistance(const std::vector<int>& nums) {
    if (!nums.size()) return 0;

    int sz = nums.size(), res = 0;
    int flag = 1;
    for (int bit = 0; bit < 32; bit++)
    {
        int ones = 0;
        for (int i = 0; i < sz; i++)
        {
            ones += (nums[i] & flag) ? 1 : 0;
        }
        res += (sz - ones) * ones;
        flag <<= 1;
    }
    return res;
}
void Test_totalHammingDistance() {
    std::vector<int> v1{4, 14, 2};
    std::cout << "total hanming distance=" << totalHammingDistance(v1) << std::endl;
}

/*
    198. 打家劫舍
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。

示例 1：
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

示例 2：
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
*/
int rob(vector<int> &nums) {

    return 0;
}
void Test_rob() {

}

/*
    338. 比特位计数
    给定一个非负整数 num。
    对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

    示例 1:
    输入: 2
    输出: [0,1,1]

    示例 2:
    输入: 5
    输出: [0,1,1,2,1,2]

    进阶:
    给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？
    要求算法的空间复杂度为O(n)。
    你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。


-----------------------------------------------------------------------
    思路
对于所有的数字，只有两类：

奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。
          举例： 
         0 = 0       1 = 1
         2 = 10      3 = 11
偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。
           举例：
          2 = 10       4 = 100       8 = 1000
          3 = 11       6 = 110       12 = 1100
另外，0 的 1 个数为 0，于是就可以根据奇偶性开始遍历计算了。
-----------------------------------------------------------------------
*/
vector<int> countBits(int num) {
    vector<int> res(num + 1);
    res[0] = 0;
    for (int i = 1; i <= num; i ++) {
         
         if ((i % 2) == 1 ) { // ji shu
             res[i] = res[i - 1] + 1;
         }
         else
         { // ou shu
            res[i] = res[ i / 2 ];
         }
    }
    return res;
}


/*
    191. 位1的个数
编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。

进阶： 如果多次调用这个函数，你将如何优化你的算法？

示例 1：
输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

示例 2：
输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。

示例 3：
输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。

-----------------------------------------------------------------------
复杂度分析

时间复杂度：O(1)O(1) 。运行时间与 nn 中位为 11 的有关。在最坏情况下， nn 中所有位都是 11 。对于 32 位整数，运行时间是 O(1)O(1) 的。

空间复杂度：O(1)O(1) 。没有使用额外空间。
-----------------------------------------------------------------------
*/
int hammingWeight(uint32_t n) {
    if (!n)
        return 0;
    int count = 0;
    while (n) {
        count++;
        n = n & (n - 1);
    }
    return count;
}
void Test_hanmingWeight() {
    std::cout << "hanming weight=" << hammingWeight(3) << std::endl;
}

/*
    70. 爬楼梯

    假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
    每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
    注意：给定 n 是一个正整数。

    示例 1：
    输入： 2
    输出： 2
    解释： 有两种方法可以爬到楼顶。
    1.  1 阶 + 1 阶
    2.  2 阶

    示例 2：
    输入： 3
    输出： 3
    解释： 有三种方法可以爬到楼顶。
    1.  1 阶 + 1 阶 + 1 阶
    2.  1 阶 + 2 阶
    3.  2 阶 + 1 阶
-----------------------------------------------------------------------
思路:f(n) = f(n-1) + f(n-2)
下一步要到达第n级阶梯, 只有通过两种方式:
一 是从第n-1阶跨1阶到达
二 是从第n-2阶跨2阶到达，而到达n-1阶和n-2阶的组合数分别为dp(n-1)和dp(n-2)，加起来则为到达n阶的结果
-----------------------------------------------------------------------
*/
int climbStairs(int n) {
   if ( n <= 2 )
        return n;
    int a, b, c;
    a = 1;
    b = 2;
    for (int i = 3; i < n; i ++) {
        c = a + b;
        a = b;
        b = c;
    }
    return c;
}
void Test_climbStairs() {
    std::cout << "climb Stairs=" << climbStairs(13) << std::endl;
}


/*
    剑指 Offer 10- I. 斐波那契数列
    写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：

    F(0) = 0, F(1) = 1
    F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
    斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

    答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

    示例 1：
    输入：n = 2
    输出：1

    示例 2：
    输入：n = 5
    输出：5
*/
int fib(int n)
{
    if (n== 0)
        return 0;
    if (n== 1)
        return 1;
    int a = 0;
    int b = 1;
    int c = 0;
    for ( int i = 2; i < n; i ++ ) {
        c = (a + b)%1000000007;
        a = b;
        b = c;
    }
    return c;
}
void Test_fib() {
    std::cout << "fib result=" << fib(1) << std::endl;
}

/*
    剑指 Offer 04. 二维数组中的查找
    在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。
    请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

    示例: 现有矩阵 matrix 如下：
    [
        [1,   4,  7, 11, 15],
        [2,   5,  8, 12, 19],
        [3,   6,  9, 16, 22],
        [10, 13, 14, 17, 24],
        [18, 21, 23, 26, 30]
    ]
    给定 target = 5， 返回 true。
    给定 target = 20，返回 false。

-----------------------------------------------------------------------
复杂度分析：
时间复杂度 O(M+N)：其中，N 和 M 分别为矩阵行数和列数，此算法最多循环 M+N 次。
空间复杂度 O(1): i, j 指针使用常数大小额外空间。
-----------------------------------------------------------------------
*/
bool findNumberIn2DArray(vector<vector<int>> &matrix, int target)
{
    int i = matrix.size() - 1;
    int j = 0;
    while (i >= 0 && j < matrix.size()) {
        if (matrix[i][j] == target) return true;
        else if (matrix[i][j] > target) i --;
        else if (matrix[i][j] < target) j ++;
    }
    return false;
}
void Test_findNumberIn2DArray() {
}

/*
    322. 零钱兑换
    给定不同面额的硬币 coins 和一个总金额 amount。
    编写一个函数来计算 可以凑成总金额所需 最少的硬币个数。
    如果没有任何一种硬币组合能组成总金额，返回 -1。

    示例 1：
    输入：coins = [1, 2, 5], amount = 11
    输出：3 
    解释：11 = 5 + 5 + 1

    示例 2：
    输入：coins = [2], amount = 3
    输出：-1

    示例 3：
    输入：coins = [1], amount = 0
    输出：0

    示例 4：
    输入：coins = [1], amount = 1
    输出：1

    示例 5：
    输入：coins = [1], amount = 2
    输出：2
*/
int coinChange(vector<int>& coins, int amount) {

    return 0;
}
void Test_coinChange() {
    std::vector<int> v1{1, 2, 5};
    std::cout << "ret=" << coinChange(v1, 11) << std::endl;
}


/*
    编号35：搜索插入位置
    给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
    你可以假设数组中无重复元素。

    示例 1:
    输入: [1,3,5,6], 5
    输出: 2

    示例 2:
    输入: [1,3,5,6], 2
    输出: 1

    示例 3:
    输入: [1,3,5,6], 7
    输出: 4

    示例 4:
    输入: [1,3,5,6], 0
    输出: 0
*/
int searchInsert(vector<int>& nums, int target) {
    int left = 0;
    int right = nums.size() - 1;

    while ( left <= right ) {
        int mid = left + ((right-left)>>1);

        if ( nums[mid] > target ) {
            right = mid - 1;
        }
        else if ( nums[mid] < target ) {
            left = mid + 1;
        } else {
            return mid;
        }
    }
    return right + 1;
}
void Test_searchInsert() {

}

/*
    34. 在排序数组中查找元素的第一个和最后一个位置
    给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
    如果数组中不存在目标值 target，返回 [-1, -1]。

    进阶： 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？

    示例 1：
    输入：nums = [5,7,7,8,8,10], target = 8
    输出：[3,4]

    示例 2：
    输入：nums = [5,7,7,8,8,10], target = 6
    输出：[-1,-1]

    示例 3：
    输入：nums = [], target = 0
    输出：[-1,-1]
-----------------------------------------------------------------------

-----------------------------------------------------------------------
*/
std::vector<int> searchRange(std::vector<int> &nums, int target) {
    std::vector<int> res;

    int n = nums.size() - 1, l = 0, r = n;

    while ( l <= r ) {
        int mid = l + ((r - l) >> 1);

        if (nums[mid] > target) {
            r = mid - 1;
        } else if (nums[mid] < target) {
            l = mid;
        } else { // == target
            int start = mid - 1, end = mid + 1;
            while ( start >= 0 && nums[start] == target )
                start--;
            while ( end < r && nums[ end ] == target )
                end++;
            res.push_back(start + 1);
            res.push_back(end - 1);
            return res;
        }
    }

    return {-1, -1};
}


/*
    365. 水壶问题
    有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？

    如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。

    你允许：
    装满任意一个水壶
    清空任意一个水壶
    从一个水壶向另外一个水壶倒水，直到装满或者倒空

    示例 1: (From the famous "Die Hard" example)
    输入: x = 3, y = 5, z = 4
    输出: True

    示例 2:
    输入: x = 2, y = 6, z = 5
    输出: False
*/
bool canMeasureWater(int x, int y, int z) {

        return true;
}

/*
    剑指 Offer 37. 序列化二叉树
    请实现两个函数，分别用来序列化和反序列化二叉树。

    示例: 你可以将以下二叉树：

         1
        / \
       2   3
          / \
         4   5

    序列化为 "[1,2,3,null,null,4,5]"
*/
class Codec {
public:

    // Encodes a tree to a single string.
    std::string serialize(BstNode* root) {

        {
            std::queue<BstNode*> que;
            que.push(root);

            std::ostringstream out;
            while (que.size()) {
                
                BstNode *tmp = que.front();
                que.pop();

                if (tmp) {
                    out << " " << tmp->val;
                    que.push(tmp->left);
                    que.push(tmp->right);
                } else {
                    out << " null ";
                }

            }// end while ---
            return out.str();
        }

    }

    // Decodes your encoded data to tree.
    BstNode* deserialize(std::string data) {
        std::istringstream input(data);

        return nullptr;
    }
};
void Test_BstCodec() {

    std::cout << std::endl;
    PrintInorder(g_pBstTree);
    std::cout << std::endl;
    // return;

    Codec c;
    auto str = c.serialize(g_pBstTree);
    std::cout << "str=" << str << std::endl;
    return ;

    std::ostringstream out;
    out << " "; out << 123;
    out << " "; out << 991;
    out << " "; out << "null";
    out << " "; out << 6677;
    out << " "; out << "null";

    std::cout << "beg --------------------" << std::endl;
    std::istringstream input(out.str());
    string val;
    while (input >> val) {
        // if (val == " ")
        //     std::cout << " find \" \"" << std::endl;
        std::cout << val << std::endl;
    }
    std::cout << "end --------------------" << std::endl;
}



/*
    39. 组合总和
    给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

    candidates 中的数字可以无限制重复被选取。

    说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。

    示例 1：
    输入：candidates = [2,3,6,7], target = 7,
    所求解集为：
    [
        [7],
        [2,2,3]
    ]

    示例 2：
    输入：candidates = [2,3,5], target = 8,
    所求解集为：
    [
        [2,2,2,2],
        [2,3,3],
        [3,5]
    ]
-----------------------------------------------------------------------
-----------------------------------------------------------------------
*/
vector<vector<int>> combinationSum(vector<int> &candidates, int target) {
    vector<vector<int>> result;

    return result;
}

void Test_combinationSum()
{
}



/*
    238. 除自身以外数组的乘积
    给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。

    示例:
    输入: [1,2,3,4]
    输出: [24,12,8,6]

    提示: 题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。
    说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。
    进阶: 你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）
-----------------------------------------------------------------------
-----------------------------------------------------------------------
*/
vector<int> productExceptSelf(vector<int> &nums) {

    int length = nums.size();
    std::vector<int> ans(length);

    // ans[i] 表示索引 i 左侧所有元素的乘积
    // 因为索引为 '0' 的元素左侧没有元素， 所以 ans[0] = 1
    ans[0] = 1;
    for (int i = 1; i < length; i++) {
        ans[i] = nums[i - 1] * ans[i - 1];
    }
    
    // R 为右侧所有元素的乘积
    // 刚开始右边没有元素，所以 R = 1
    int R = 1;
    for (int i = length - 1; i >= 0; i++) {
        ans[i] = ans[i] * R;
        // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上
        R *= nums[i];
    }

    return ans;
}
void Test_productExceptSelf() {
    std::vector<int> v1{1, 2, 3, 4};
    auto ret1 = productExceptSelf(v1);

    PrintInContainer(ret1);
}

/*
    48. 旋转图像
    给定一个 n × n 的二维矩阵表示一个图像。
    将图像顺时针旋转 90 度。
    说明：你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

    示例 1:
    给定 matrix = 
    [
        [1,2,3],
        [4,5,6],
        [7,8,9]
    ],
    原地旋转输入矩阵，使其变为:
    [
        [7,4,1],
        [8,5,2],
        [9,6,3]
    ]

    示例 2:
    给定 matrix =
    [
        [ 5, 1, 9,11],
        [ 2, 4, 8,10],
        [13, 3, 6, 7],
        [15,14,12,16]
    ], 
    原地旋转输入矩阵，使其变为:
    [
        [15,13, 2, 5],
        [14, 3, 4, 1],
        [12, 6, 8, 9],
        [16, 7,10,11]
    ]
*/
void rotateMatrix(vector<vector<int>>& matrix) {
    
}
void Test_rotateMatrix() {

}

/*
    96. 不同的二叉搜索树
    给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

    示例:
    输入: 3
    输出: 5
    解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

        1         3     3      2      1
        \       /     /      / \      \
        3     2     1      1   3      2
        /     /       \                 \
        2     1         2                 3

*/
int numTrees(int n) {

    return 1;
}
void Test_numTrees() {

}

/*
    208. 实现 Trie (前缀树)
    实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。

    示例:
    Trie trie = new Trie();
    trie.insert("apple");
    trie.search("apple");   // 返回 true
    trie.search("app");     // 返回 false
    trie.startsWith("app"); // 返回 true
    trie.insert("app");   
    trie.search("app");     // 返回 true

    说明:
    你可以假设所有的输入都是由小写字母 a-z 构成的。
    保证所有输入均为非空字符串。

*/
class Trie {
    bool isEnd;
    Trie* next[26];

public:
    /** Initialize your data structure here. */
    Trie() {
        isEnd = false;
        memset(next, 0, sizeof(next));
    }

    /** Inserts a word into the trie. */
    void insert(string word) {
    }
    
    /** Returns if the word is in the trie. */
    bool search(string word) {
        return true;
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        return true;
    }
};


void LeetCodeEntry() {
    Trie* next[26];

    std::cout << "sizeof(Trie)=" << array_size(next) << std::endl;
    return;

    Test_productExceptSelf();
    return;

    Test_BstCodec();
    return;

    Test_coinChange();
    return;

    Test_C11Random();
    return;

    Test_hanmingWeight(); return;
    
    Test_totalHammingDistance();
    return;

    Test_sumOfLeftLeaves(); return;

    Test_binaryTreePaths(); return;

    Test_getNodesNum(); return;

    Test_invertTree(); return;

    Test_hanmingDistance(); return;

    CSortedListToBst sortl2bst;
    sortl2bst.TstEntry();
    return;

    TstList1(); return;

    // Test_KthLeastNumbers();
    tst_KthBig(); return;

    std::vector<int> a{11, 23, 35, 47, 51, 53, 198, 2739, 31798};
    ListNode* retnode = ConstructList(a);
    PrintList(retnode);
    return;

    tstupper_bound(); return;
    {
        list<int> l1 = { 1, 2, 3, 4, 5 };
        list<int> l2 = { 6, 7, 8 };
        list<int>::iterator it;

        // iterator pointing to 1
        it = l1.begin();

        // advance the iterator by 2 positions
        printf("--- it=%d\n", *it);

        printf("--- l2 beg\n");
        advance(it, 2);
        printf("--- l2 end\n");
        printf("--- it=%d\n", *it);
        printf("\n"); //

        // transfer 3, 4 and 5 at the
        // beginning of l2
        l2.splice(l2.begin(), l2, it, l1.end());

        cout << "list l2 after splice operation" << endl;
        for (auto x : l2)
            cout << x << " ";

        cout << std::endl;

        printf("l1 beg\n");
        PrintInContainer(l1);//
        printf("l1 end\n");
        return;
    }
    {
        std::list < int > l1, l2;
        std::list < int >::iterator it;

        for ( int i = 0; i < 4; i ++ ) {
            l1.push_back(i+1);
        }
        for ( int i = 10; i <= 30; i += 10 ) {
            l2.push_back(i);
        }
        printf("--- l2 beg\n");
        PrintInContainer(l2);//  1 10 20 30 2 3 4
        printf("--- l2 end\n");
        printf("\n"); //

        it = l1.begin();
        ++ it;
        printf("it=%d\n", *it); // 2

        l1.splice(it, l2);

        PrintInContainer(l1);//  1 10 20 30 2 3 4
        printf("\n"); //

        printf("l2 beg\n");
        PrintInContainer(l2);//
        printf("l2 end\n");
        return;
    }

    {
        ObjA* oa = ObjA::GetInstance();
        oa->PrintSomeInfo();
        ObjA ot;
//        ObjA ov = ot;
        return ;
    }

    {
//        string home = "./logs";  //要先创建此目录,否则运行报错.
//        google::InitGoogleLogging("tstout");

//        string info_log = home + "master_info_";
//        info_log = home;
//        google::SetLogDestination(google::INFO, info_log.c_str());

//        string warning_log = home + "master_warning_";
//        warning_log = home;
//        google::SetLogDestination(google::WARNING, warning_log.c_str());

//        string error_log = home + "master_error_";
//        error_log = home;
//        google::SetLogDestination(google::ERROR, error_log.c_str());

//        string fatal_log = home + "master_fatal_";
//        fatal_log = home;
//        google::SetLogDestination(google::FATAL, fatal_log.c_str());

//        google::SetStderrLogging(google::GLOG_INFO);
        FLAGS_alsologtostderr = 1;

        // You can specify one of the following severity levels (in increasing order of severity)
        LOG(INFO) << "info";
        LOG(WARNING) << "warning";
        LOG(ERROR) << "error";
//        LOG(FATAL) << "fatal";   // Logging a FATAL message terminates the program (after the message is logged)!

//        return ;
    }

//    google::InitGoogleLogging("outlog");
//    google::SetLogDestination(google::GLOG_INFO, "loge");
//    google::SetStderrLogging(google::GLOG_WARNING);
//    google::SetStderrLogging(google::GLOG_INFO);
//    FLAGS_colorlogtostderr=true;

//    LOG(INFO) << "check tst";
//    google::InitGoogleLogging("outlog");
    for (int i = 0; i < 10; ++i) {
        LOG_IF(INFO, i > 5) << "LOG_IF i > 5 i:" << i;
        LOG_EVERY_N(INFO, 3) << "LOG_EVERY_N 3 i:" << i << " google::COUNTER:" << google::COUNTER;
        LOG_IF_EVERY_N(INFO, (i > 5), 2) << "LOG_IF_EVERY_N i > 5 2 i:" << i;
        LOG_FIRST_N(INFO, 4) << "LOG_FIRST_N 4 i:" << i << " google::COUNTER:" << google::COUNTER;
    }
    return ;

    CheckIfBst chck;
    std::cout << "chck result=" << chck.IsValidBst_1(g_pBstTree) << std::endl;

    return ;
    CheckHuiWen checkHuiwen;
    checkHuiwen.IsHuiWen();
    return;


    int i1 = 4;
    int i2 = 12;
    UNUSED(i2);
    int ret = i1 & (-i1) ;
    std::cout << "-i1=" << -i1 << std::endl;
    std::cout << "ret=" << ret << std::endl;
    return ;

    CBuildBstByPreInorder buildBst;
    buildBst.WorkEntry();
    return;


    tst_1_lc();
}
