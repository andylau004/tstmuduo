


#include <stdio.h>
#include <stdlib.h>


#include "lc.h"

#include "List.h"
#include "tstList.h"


//#define GOOGLE_STRIP_LOG 1
#include <glog/logging.h>
#define GOOGLE_STRIP_LOG 1



//#define LOG_TRACE LOG(INFO)
//#define LOG_DEBUG LOG(INFO)
#define LOG_INFOEX   LOG(INFO)
//#define GDLOG_TRACEEX LOG(INFO) << __PRETTY_FUNCTION__ << " this=" << this << " "
//#else

extern int tst_rand();
extern int tst_rand(int low, int high);
extern void AddNewNode(BstNode*& root, BstNode* newNode);
extern void printInorder(BstNode* root);


extern BstNode* g_pBstTree;


/* --------------------------------------------------------------------------
 1. Convert Sorted Array to Binary Search Tree
 2. Convert Sorted List to Binary Search Tree

 * --------------------------------------------------------------------------*/


void Test_C11Random() {
    std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_int_distribution<> distrib(1, 6);
 
    for (int n=0; n<10; ++n)
        //Use `distrib` to transform the random unsigned int generated by gen into an int in [1, 6]
        std::cout << distrib(gen) << ' ';
    std::cout << '\n';
}


// Convert Sorted Array to Binary Search Tree
// Given an array where elements are sorted in ascending order, convert it to a height balanced BST.
// 思路：
// 给定一个区间[left, right]，取其中值mid=(left+right)/2对应的元素作为二叉树的根。二叉树的左子树根的值为对[left, mid-1]继续操作的结果，右子树类似。

void someInOrder(TreeNode* root);
void InOrtderPtrint(TreeNode* root);

//class Solution {
//public:
TreeNode *generateBST(int left, int right, std::vector<int> &vec)
{
    if (left > right)
    {
        return nullptr;
    }
    else if (left == right)
    {
        return new TreeNode(vec[left]);
    }
    else
    {
        int mid1 = (left + right) >> 1;
//            printf("mid1=%d\n", mid1);

        TreeNode *newnode = new TreeNode(vec[mid1]);
        newnode->left = generateBST(0, mid1 - 1, vec);
        newnode->right = generateBST(mid1 + 1, right, vec);
        return newnode;
    }
}
TreeNode *sortedArrayToBst(std::vector<int> &vec)
{
    return generateBST(0, vec.size() - 1, vec);
}
void InOrtderPtrint(TreeNode *root)
{
    std::cout << std::endl;
    someInOrder(root);
    std::cout << std::endl;
}
void someInOrder(TreeNode *root)
{
    if (!root)
    {
        printf("root is null\n");
        return;
    }
    if (root->left)
        someInOrder(root->left);
    std::cout << root->val << '\t';
    if (root->right)
        someInOrder(root->right);
}

    // std::vector<int> createRandomIntVector(int start, int end, int numCount) {
    //         time_t t;
    //         srand(time(&t));

    //     std::vector<int> ret;
    //     for (int i = 0; i < numCount; ++i) {
    //         ret.push_back(tst_rand(start, end));
    //     }
        
    //     return ret;
    // }

    std::vector< ListNode* > ConstructTestListByParam(int start, int end, int numCount, int listCount) {
        std::vector< ListNode* > arrays;
        // ----------------
        time_t t;
        srand(time(&t));
        for ( int i = 0; i < listCount; i ++ ) {
            std::vector<int> tmpArr;
            for ( int j = 0; j < numCount; j ++ ) {
                tmpArr.push_back(tst_rand(start, end));
            }
            arrays.push_back( ConstructTestList(tmpArr) );
        }
        // ----------------
        return arrays;
    }



// Convert Sorted List to Binary Search Tree -- LeetCode 将有序链表转为二叉搜索树
class CSortedListToBst {
public:

    ListNode* reverseList( ListNode* pHead ) {
        if (!pHead) return nullptr;
        {
            ListNode* prePtr = nullptr, *curPtr = pHead, *nextPtr = curPtr->next;
            while (nextPtr) {
                curPtr->next = prePtr;
                prePtr = curPtr;

                curPtr = nextPtr;
                nextPtr = nextPtr->next;
            }
            curPtr->next = prePtr;
            return curPtr;
        }

        ListNode* prePtr = nullptr, *curPtr = pHead, *nextPtr = curPtr->next;
        while (nextPtr) {
            curPtr->next = prePtr;
            prePtr = curPtr;

            curPtr = nextPtr;
            nextPtr = nextPtr->next;
        }
        curPtr->next = prePtr;
        return curPtr;
    }



    void TstEntry() {
        std::vector<int> l{11, 23, 36, 47, 51, 53, 198, 2739, 31798};
        auto headList = ConstructList(l);

        TreeNode* root = SortedListToBst(headList);
        PrintList(headList);

        std::cout << std::endl << std::endl
                  << " in order print tree beg---------" << std::endl;
        someInOrder(root);
        std::cout << std::endl
                  << " in order print tree end---------" << std::endl;
    }
    TreeNode* SortedListToBst(ListNode* head) {
        if (!head) return nullptr;
        helper(head, nullptr);
    }
    TreeNode* helper(ListNode* head, ListNode* tail) {
        if (head == tail) return nullptr;

        ListNode* slow = head, *fast = head;
//        std::cout << "slow=" << slow <<std::endl;
//        std::cout << "fast=" << fast <<std::endl;

        while (fast != tail && fast->next != tail) {
            slow = slow->next;
            fast = fast->next->next;
        }
//        std::cout << "slow->val=" << slow->val << std::endl;
//        std::cout << "fast->val=" << fast->val << std::endl;
//        return nullptr;

        TreeNode* root = new TreeNode(slow->val);
        root->left = helper(head, slow);
        root->right = helper(slow->next, tail);
        return root;
    }

};

void TstList1()
{
    std::vector<int> l{11, 23, 35, 47, 51, 53, 198, 2739, 31798};
    ListNode *headL = ConstructList(l);
    PrintList(headL);

    // CSortedListToBst listObj;
    // listObj.TstList1();

    // ListNode* pReverseList = reverseList( pNode1 );
    // PrintList(pReverseList);
}

/*
        105. 从前序与中序遍历序列构造二叉树
        根据一棵树的前序遍历与中序遍历构造二叉树。

        注意: 你可以假设树中没有重复的元素。

        例如: 给出
        前序遍历 preorder = [3,9,20,15,7]
        中序遍历 inorder  = [9,3,15,20,7]
        返回如下的二叉树：
            3
           / \
          9  20
            /  \
           15   7

    首先要知道一个结论，前序/后序+中序序列可以唯一确定一棵二叉树，所以自然而然可以用来建树。
    看一下前序和中序有什么特点，前序1,2,4,7,3,5,6,8，中序4,7,2,1,5,3,8,6；

    有如下特征：
    1. 前序中左起第一位1肯定是根结点，我们可以据此找到中序中根结点的位置rootin；
    2. 中序中根结点左边就是左子树结点，右边就是右子树结点，即[左子树结点，根结点，右子树结点]，
       我们就可以得出左子树结点个数为int left = rootin - leftin;；
    3. 前序中结点分布应该是：[根结点，左子树结点，右子树结点]；
    4. 根据前一步确定的左子树个数，可以确定前序中左子树结点和右子树结点的范围；
    5. 如果我们要前序遍历生成二叉树的话，下一层递归应该是：
        左子树：root->left = pre_order(前序左子树范围，中序左子树范围，前序序列，中序序列);；
        右子树：root->right = pre_order(前序右子树范围，中序右子树范围，前序序列，中序序列);。
    6. 每一层递归都要返回当前根结点root；
*/
class CBuildBstByPreInorder {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int pos = 0;
        return buildTree(preorder, pos, inorder, 0, preorder.size() - 1);
    }

    TreeNode* buildTree(vector<int>& preorder, int& pos, vector<int>& inorder, int left, int right) {
        int m = preorder.size();
        if(m == 0) return NULL;
        TreeNode* root = new TreeNode(preorder[0]);
        vector<int> preorder_left, inorder_left, preorder_right, inorder_right;
        //在inorder里面寻找根节点，划分左子树和右子树
        int i;
        //构造左子树的中序遍历
        for(i = 0; i < m; i ++){
            if(inorder[i] == preorder[0]) break;
            inorder_left.push_back(inorder[i]);
        }
        //构造右子树的中序遍历
        for(i = i + 1; i < m; i ++){
            inorder_right.push_back(inorder[i]);
        }
        for(int j = 1; j < m; j ++){
            //构造左子树的前序遍历
            if(j <= inorder_left.size()) preorder_left.push_back(preorder[j]);
            //构造右子树的前序遍历
            else preorder_right.push_back(preorder[j]);
        }
        root->left = buildTree(preorder_left, inorder_left);
        root->right = buildTree(preorder_right, inorder_right);
        return root;
//        if (pos >= preorder.size()) return 0;
//        int i = left;
//        for (; i <= right; ++i) {
//            if (inorder[i] == preorder[pos]) break;
//        }
//        TreeNode* newNode = new TreeNode(preorder[pos]);
//        if (left <= i-1)
//            newNode->left  = buildTree(preorder, ++pos, inorder, left, i-1);  // 左子树
//        if (i+1 <= right)
//            newNode->right = buildTree(preorder, ++pos, inorder, i + 1, right);  // 右子树
//        return newNode;
    }

    void WorkEntry() {
//        std::vector < int > preOrder = {1,2,4,7,3,5,6,8};
//        std::vector < int > inOrder  = {4,7,2,1,5,3,8,6};
        std::vector < int > preOrder = {3,9,20,15,7};
        std::vector < int > inOrder  = {9,3,15,20,7};
        TreeNode* root = buildTree(preOrder, inOrder);
        InOrtderPtrint(root);
    }
};
void tst_buildTree() {
    CBuildBstByPreInorder buildBst;
    buildBst.WorkEntry();
}




    void tst_1_lc() {
        std::vector<int> vecArr{ -10,-3,0,5,9};
        TreeNode* root = sortedArrayToBst(vecArr);
        std::cout << std::endl;
        someInOrder(root);
        std::cout << std::endl;
    }


    // LeetCode 215. Kth Largest Element in an Array--数字第K大的元素
    // 从大到小排列；
class CFindKthBigest {

public:
    // int sort_desc(vector<int>& nums, int l, int r, int k) {

    //     {
    //         if ( l > r ) return -1;

    //         int i = l, j = r;
    //         int tmp = nums [ i ];

    //         while ( i < j ) {
    //             while ( i < j &&  nums [ j ] >= tmp ) j --;
    //             if ( i < j ) nums [ i ++ ]  = nums[ j ];

    //             while ( i < j  &&  nums [ i ] <= tmp ) i ++;
    //             if ( i < j ) nums [ j -- ] = nums[ i ];
    //         }
    //         nums[ i ] = tmp;

    //         if ( i == k ) return nums[ i ];
    //         else if ( i < k ) return sort_desc(nums, i + 1, r, k);
    //         else return sort_desc( nums, l, i - 1, k );
    //     }
    // }
    int partition( std::vector<int>& nums, int left, int right ) {

        int pivot = nums[ left ];

        while ( left < right ) {

            while ( left < right && nums[ right ] >= pivot ) right --;
            if ( left < right ) nums[ left ] = nums[ right ];

            while ( left < right && nums [ left ] <= pivot ) left ++;
            if ( left < right ) nums[ right ] = nums[ left ];
        }
        nums[ left ] = pivot;
        return left;
    }
    int findKthLargest(vector<int>& nums, int k) {
        int sz = nums.size();
        int newK = sz - k;

        int left = 0;
        int right = sz - 1;

        while ( 1 ) {
            auto pos = partition( nums, left, right );
            
            if ( pos == newK ) {
                return nums[ pos ];
            }
            else if ( newK < pos ) {
                right = pos - 1;
            } else {
                left = pos + 1;
            }
        }
        return -1;
        // int length = nums.size();
        // if (k > length) return 0;

        // return sort_desc(nums, 0, length-1, length-k);
    }

    void sort_impl(vector<int>& nums, int l, int r) {
        if ( l > r ) return;
        int i = l, j = r;
        int tmp = nums [ i ];

        while ( i < j ) {
            while ( i < j  && nums [ j ] >= tmp ) j --;
            if ( i < j ) nums [ i ++ ] = nums [ j ];

            while ( i < j &&  nums [ i ] <= tmp ) i ++;
            if ( i < j ) nums [ j -- ] = nums [ i ];
        }
        nums [ i ] = tmp;

        sort_impl( nums, l, i - 1 );
        sort_impl( nums, j + 1, r );
    }
    void sortByQuickSort(vector<int>& nums) {
        sort_impl( nums, 0, nums.size() - 1 );
    }

    void sortByPriQue(vector<int>& nums, int k) {

//        std::priority_queue<int, vector<int>, less<int>> que(nums.begin(), nums.end());
//        std::priority_queue<int, vector<int>, greater<int>> que(nums.begin(), nums.end());

        std::priority_queue<int, vector<int>, greater<int>> que;
        for ( int i = 0; i < nums.size(); i ++ ) {

            if (i < k ) {
                que.push(nums[i]);
            } else if (nums[i] > que.top()) {
                que.pop();
                que.push(nums[i]);
            }
        }
        std::cout << "size=" << que.size() << ", top=" << que.top() << "\n";
//        return;

        for ( int i = 0; i < 3; i ++ ) {
            auto ele = que.top();
            std::cout << ele << " ";
            que.pop();
        }
        std::cout << "\n";
//        PrintInContainer(que);
    }
};


    /*
        上面两种方法虽然简洁，但是确不是本题真正想考察的东西，可以说有一定的偷懒嫌疑。
        这道题最好的解法应该是下面这种做法，用到了快速排序 Quick Sort 的思想，
        这里排序的方向是从大往小排。
        核心思想是每次都要先找一个中枢点 Pivot，然后遍历其他所有的数字，像这道题从大往小排的话，
        就把大于中枢点的数字放到左半边，把小于中枢点的放在右半边，这样中枢点是整个数组中第几大的数字就确定了，
        虽然左右两部分各自不一定是完全有序的，但是并不影响本题要求的结果，
        因为左半部分的所有值都大于右半部分的任意值，所以我们求出中枢点的位置，
        如果正好是 k-1，那么直接返回该位置上的数字；
        如果大于 k-1，说明要求的数字在左半部分，更新右边界，再求新的中枢点位置；
        反之则更新右半部分，求中枢点的位置；
    */
    void tst_KthBig() { // 数组中第k大的数字

        int idx = 3;
        std::vector < int > vRandom =
             { 9, 1, 123, 6613, 31, 25, 123, -333,  72,  19, 9981, 33812, -17 };

        {
//            auto cpy = vRandom;

//            CFindKthBigest cf;
////            cf.sortByQuickSort(cpy);
//            cf.sortByPriQue(cpy, idx);

//            PrintInContainer(cpy);
//            return;
        }
//        auto retVal = sort_desc(vRandom, 0, vRandom.size() - 1, idx);

        PrintInContainer(vRandom);

        CFindKthBigest cf;
        auto retVal = cf.findKthLargest(vRandom, idx);

//        auto retVect = findKthLargest( vRandom, idx );
        // PrintInContainer(retVect);
        std::cout << "idx=" << idx << ", Max Val Kth=" << retVal << std::endl;
        return;

{// -333 -17 1 9 19 25 31 72 123 123 6613 9981 33812
        // std::priority_queue<int, std::vector<int>, greater<int>> que(vRandom.begin(), vRandom.end());
        // for (size_t i = 0; i < vRandom.size(); ++i) {
        //     std::cout << " " << que.top() ;
        //     que.pop();
        // }
        // std::cout << std::endl;
        // return;
}

{ // the newest work code ---- 大顶堆方式
// 33812 9981 6613 123 123 72 31 25 19 9 1 -17 -333
        priority_queue<int> q(vRandom.begin(), vRandom.end());
        for (size_t i = 0; i < (size_t)(idx - 1); ++i) {
            std::cout << " pop=" << q.top() ;
            q.pop();
        }
        std::cout << std::endl;
        std::cout << "idx=" << idx << ", Max Val Kth=" << q.top() << std::endl;
        return;
}

    }


void Test_KthLeastNumbers() {
    int k = 5;
    std::vector<int> arr { 1, 7, 123, -333, -4236, -33391,  72,  19, 9981, 33812, -17 };
{
        priority_queue<int, vector<int>, greater<int>> smallqueue;
        vector<int> result;

        for (size_t i = 0; i < arr.size(); i++) {
            smallqueue.push(arr[i]);
        }
        
    // PrintInPriorQue(smallqueue);
    //     return;

        int n = 0;
        while (n < k && !smallqueue.empty()) {
            result.push_back(smallqueue.top());
            smallqueue.pop();
            n++;
        }

        PrintInContainer(result);
        return;
}
    std::priority_queue<int, std::vector<int>> que;
    // std::priority_queue<int, vector<int>, greater<int>> smallqueue;

    for ( auto ele : arr ) {

        if (que.size() < k) {
            que.push(ele);
        } else {
            que.push(ele);
            que.pop();
        }
    }

    while ( !que.empty() ) {
        auto ele = que.top();
        que.pop();
        std::cout << " " << ele;
    }
    std::cout << std::endl;
}



/*
 * 根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。
 * 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。
 * 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。
 * // https://leetcode-cn.com/problems/daily-temperatures/solution/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/
*/
std::vector<int> dailyTemperatures(std::vector<int>& temperatures) {
    int n = temperatures.size();
    std::vector<int> res(n, 0);
    std::stack<int> st;
    for (size_t i = 0; i < temperatures.size(); ++i) {
        while (!st.empty() && temperatures[i] > temperatures[st.top()]) {
            auto t = st.top(); st.pop();
            res[t] = i - t;
        }
        st.push(i);
    }
    return res;
}


/*
        给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。

        示例:

        输入: 3
        输出:
        [
          [1,null,3,2],
          [3,2,null,1],
          [3,1,null,null,2],
          [2,1,3],
          [1,null,2,null,3]
        ]

        解释:
        以上的输出对应以下 5 种不同结构的二叉搜索树：

           1         3     3      2      1
            \       /     /      / \      \
             3     2     1      1   3      2
            /     /       \                 \
           2     1         2                 3
*/

class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 2, 0);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; ++i) {
            for (int j = 0; j < i; ++j) {
                dp[i] += dp[j] * dp[i - j - 1];
            }
        }
        return dp[n];
    }
};




/*
    思路一：中心扩散
    从开始每个字符进行判断，回文串字符个数可能为奇数或偶数

    如果是奇数，则中心字符为当前字符，然后向两边扩散
    如果是偶数，则中心字符为当前字符和下一个字符，然后向两边扩散
*/
class CheckHuiWen
{
public:
    void IsHuiWen() {
        std::string str = "abtx21ba";

        int sum = 0;
        for (size_t i = 0; i < str.size(); ++ i) {
            sum += helper(str, i, i);
            sum += helper(str, i, i+1);
        }
        std::cout << "sum=" << sum << std::endl;
        std::cout << "str.size=" << str.size() << std::endl;
    }

    int helper(std::string& str, size_t i, size_t j) {
        int sum = 0;
        if (i >= 0 && j < str.size() && str[i] == str[j]) {
            --i, j++, sum++;
        }
        return sum;
    }
};


/*
    给定一个二叉树，判断它是否是高度平衡的二叉树。

    本题中，一棵高度平衡二叉树定义为：

    一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过1。

    示例 1:

    给定二叉树 [3,9,20,null,null,15,7]

        3
       / \
      9  20
        /  \
       15   7
    返回 true

    示例 2:

    给定二叉树 [1,2,2,3,3,null,null,4,4]

           1
          / \
         2   2
        / \
       3   3
      / \
     4   4
    返回 false
*/

int Depth(BstNode* root) {
    if (!root) return 0;
    return std::max(Depth(root->left), Depth(root->right)) + 1;
}
bool isBalanced(BstNode* root) {
    if (!root) return true;

    int d = abs( Depth(root->left) - Depth(root->right) );
    bool bCheck = (d <= 1 && isBalanced(root->left) && isBalanced(root->right));
    std::cout << "d=" << d << std::endl;
    return bCheck;
}

/*
        Leetcode 98. 验证二叉搜索树
        给定一个二叉树，判断其是否是一个有效的二叉搜索树。

        二叉搜索树具有如下特征：
        节点的左子树只包含小于当前节点的数。
        节点的右子树只包含大于当前节点的数。
        所有左子树和右子树自身必须也是二叉搜索树。

        示例 1:
        输入:
            2
           / \
          1   3
        输出: true

        示例 2:
        输入:
            5
           / \
          1   4
             / \
            3   6
        输出: false
        解释: 输入为: [5,1,4,null,null,3,6]。
             根节点的值为 5 ，但是其右子节点值为 4 。
*/
class CheckIfBst {
public:
//    bool IsValidBst(BstNode* root) {
//        if (!root) return true;
//        return IsLeftBst(root->left, root->val) && IsRightBst(root->right, root->val);
//    }
//    bool IsLeftBst(BstNode* root, int val) {
//        if (IsValidBst(root)) {
//            while (root) {
//                if (root->val >= val) return fasle;
//                root = root->right;
//            }
//            return true;
//        } else {
//            return false;
//        }
//    }
//    bool IsRightBst(BstNode* root, int val) {
//        if (IsValidBst(root)) {

//        }
//    }

    bool IsValidBst_1(BstNode* root) {
        UNUSED(root);
//        std::vector<int> arrVal;
//        inorder(root, arrVal);
//        for (size_t i = 0; i < arrVal.size(); i++) {
//            if (arrVal[i] <= arrVal[i-1]) return false;
//        }
        return true;
    }
    void inorder(BstNode* root, std::vector<int>& arrVal) {
        UNUSED(root);
        UNUSED(arrVal);
//        if (!root) return;
//        inorder(root->left, arrVal);
//        arrVal.push_back(root->val);
//        inorder(root->right, arrVal);
    }

};



#define DISABLE_COPY(ClassName) \
    ClassName(const ClassName&) = delete;
#define DISABLE_ASSIGN(ClassName) \
    ClassName& operator=(const ClassName&) = delete;


class ObjA
{
//public:
    DISABLE_COPY(ObjA)
    DISABLE_ASSIGN(ObjA)
public:
    ObjA() {

    }
public:
    void PrintSomeInfo() {
        std::cout << "val ---- " << std::endl;
    }
    static ObjA* GetInstance() {
        return (new ObjA);
    }
};

/**
 * 二分查找
 * @param n int整型 数组长度
 * @param v int整型 查找值
 * @param a int整型vector 有序数组
 * @return int整型
 */
int upper_bound_(int n, int v, vector<int>& a) {
    int left = 0, right = n - 1;
    int mid = 0;
    while ( left < right ) {
        mid = (left + right) >> 1;
//        sleep(1);
//        std::cout << "mid=" << mid  << std::endl;
//        if (a[mid] < v) {
//            right = mid + 1;
//        } else {
//            right = mid;
//        }
        if ( a[ mid ] >= v ) {
            if ( mid == 0 || a[mid - 1] < v ) {
                return mid/* + 1*/;
            }
            else {
                right = mid;
            }
        } else {
            left = mid + 1;
        }
    }
    return n + 1;
}

void tstupper_bound() {
    std::vector<int> a{1, 2, 3, 4, 4, 5};
    std::cout << upper_bound_(a.size(), 4, a) << std::endl;
}


/*
    461. 汉明距离
两个整数之间的汉明距离, 指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 x 和 y，计算它们之间的汉明距离。

注意： 0 ≤ x, y < 231.

示例: 输入: x = 1, y = 4
输出: 2
解释:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
上面的箭头指出了对应二进制位不同的位置。
*/
int hammingDistance(int x, int y) {
    int xorRes = x ^ y;
    int count  = 0;
    while (xorRes > 0) {
        if (1 == (xorRes & 1)) {
            count++;
        }
        xorRes = xorRes >> 1;
    }
    return count;
}
void Test_hanmingDistance() {
    auto ret = hammingDistance(1, 22);
    std::cout << "result=" << ret << std::endl;
}


/*
    226. 翻转二叉树
示例：
输入：
     4
   /   \
  2     7
 / \   / \
1   3 6   9
输出：
     4
   /   \
  7     2
 / \   / \
9   6 3   1
备注:
这个问题是受到 Max Howell 的 原问题 启发的 ：
谷歌：我们90％的工程师使用您编写的软件(Homebrew)，
但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。
*/
BstNode* invertTree(BstNode* root) {
    if (!root) return nullptr;
    BstNode* left  = invertTree(root->left);
    BstNode* right = invertTree(root->right);
    root->left = right;
    root->right = left;
    return root;
}
void Test_invertTree() {

    PrintInorder(g_pBstTree);
    
    invertTree(g_pBstTree);
    
    PrintInorder(g_pBstTree);
}

/*
    104. 二叉树的最大深度

*/



/*
    222.二叉树的节点个数/二叉树：有多少个节点
    给出一个二叉树，求出该树的节点个数。
*/
int countNodes(BstNode* cur) {
    if (!cur) return 0;
    return 1 + countNodes(cur->left) + countNodes(cur->right);
}
void Test_getNodesNum() {
    PrintInorder(g_pBstTree);

    int kNums = countNodes(g_pBstTree);
    std::cout << "kNums=" << kNums << std::endl;
}

/*
    111.二叉树的最小深度
    给定一个二叉树，找出其最小深度。

    最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

    说明: 叶子节点是指没有子节点的节点。
    示例 1：
    输入：root = [3,9,20,null,null,15,7]
    输出：2

    示例 2：
    输入：root = [2,null,3,null,4,null,5,null,6]
    输出：5
*/
int minDepth(TreeNode *root)
{
    if (!root) return 0;

    int lmin = minDepth(root->left);
    int rmin = minDepth(root->right);
    if (!lmin && !rmin)
        return 1;
    if (!lmin || !rmin)
        return (lmin + rmin + 1);
    return (std::min(lmin, rmin) + 1);
}
void Test_minDepth() {
}

/*
257. 二叉树的所有路径
给定一个二叉树，返回所有从根节点到叶子节点的路径。

说明: 叶子节点是指没有子节点的节点。

示例: 输入
   1
 /   \
2     3
 \
  5

输出: ["1->2->5", "1->3"]

解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3
*/
void traversal(BstNode* cur, string path, vector<string>& result) {
    path += to_string(cur->val);
    if (!cur->left && !cur->right) {
        result.push_back(path);
        return;
    }
    if (cur->left) {
        traversal(cur->left, path + "->", result);
    }
    if (cur->right) {
        traversal(cur->right, path + "->", result);
    }
}
vector<string> binaryTreePaths(BstNode *root) {
    std::vector<string> result;
    std::string path;
    if (!root) return result;

    traversal(root, path, result);
    return result;
}
void tst_binaryTreePaths() {
    std::cout << "before handle ..." << std::endl;
    PrintInorder(g_pBstTree);
    std::cout << std::endl;

    auto paths = binaryTreePaths(g_pBstTree);
    PrintInContainer(paths);
}

/*
404. 左叶子之和
计算给定二叉树的所有左叶子之和。
示例：
    3
   / \
  9  20
    /  \
   15   7
在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24

「首先要注意是判断左叶子，不是二叉树左侧节点，所以不要上来想着层序遍历。」

左叶子的定义：「如果左节点不为空，且左节点没有左右孩子，那么这个节点就是左叶子」

------------------------ 提示 ------------------------
如果该节点的左节点不为空，该节点的左节点的左节点为空，该节点的左节点的右节点为空，则找到了一个左叶子，判断代码如下：

if (node->left != NULL && node->left->left == NULL && node->left->right == NULL) {
    左叶子节点处理逻辑
}
*/
int sumOfLeftLeaves(BstNode *root) {
    if (!root) return 0;
    int res = 0;
    if (root->left && root->left->left == nullptr && root->left->right) {
        res = root->left->val;
    }
    return res + sumOfLeftLeaves(root->left) + sumOfLeftLeaves(root->right);
}
void Test_sumOfLeftLeaves() {
    std::cout << "before handle ..." << std::endl;
    PrintInorder(g_pBstTree);
    std::cout << std::endl;

    std::cout << "sum=" << sumOfLeftLeaves(g_pBstTree) << std::endl;
}

/*
    513. 找树左下角的值
    一个二叉树，在树的最后一行找到最左边的值。

示例 1:
输入:
    2
   / \
  1   3
输出: 1

示例 2:
输入:
        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7
输出: 7

-----------------------------------------------------------------------
如果需要搜索整颗二叉树，那么递归函数就不要返回值。
如果需要搜索其中一条符合条件的路径，递归函数就需要返回值，因为遇到符合条件的路径，就要及时返回。
-----------------------------------------------------------------------
*/
class CFindLeftMinVal {
    int maxLeftVal = INT_MIN;
    int maxDepth   = INT_MIN;

void traversal_for_leftTree(BstNode *root, int tmpDepth)
{
    if (nullptr == root->left && nullptr == root->right) {
        if (tmpDepth > maxDepth) {
            maxLeftVal = root->val;
            maxDepth = tmpDepth;
            return;
        }
    }
    if (root->left)  traversal_for_leftTree(root->left, tmpDepth + 1);
    if (root->right) traversal_for_leftTree(root->right, tmpDepth + 1);
}
public:
    int findBottomLeftValue(BstNode *root) {
        traversal_for_leftTree(root, 0);
        return maxLeftVal;
    }
};

/*
    112. 路径总和
    给定一个二叉树和一个目标和，判断该树中是否存在 根节点到叶子节点的 路径，这条路径上所有节点值相加和 等于 目标。

    说明: 叶子节点是指没有子节点的节点。

    示例: 给定如下二叉树，以及目标和 sum = 22，
                  5
                 / \
                4   8
               /   / \
              11  13  4
             /  \      \
            7    2      1
    返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2

    -----------------------------------------------------------------------
复杂度分析：
    时间复杂度： O(N)，其中 N 是树的节点数。对每个节点访问一次。
    空间复杂度： O(H)，其中 H 是树的高度。
    空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。
    平均情况下树的高度与节点数的对数正相关，空间复杂度为 O(logN)。
    -----------------------------------------------------------------------
*/
bool hasPathSum(BstNode *root, int sum) {
    if (!root)
        return false;
    if (root->left == nullptr && root->right == nullptr) {
        return sum == root->val;
    }
    return hasPathSum(root->left, sum - root->val) && hasPathSum(root->right, sum - root->val);
}
class CPathCollect {
public:
    std::vector<int> path;

    std::vector< std::vector<int> > PathGet(BstNode* root, int sum) {

        std::vector< std::vector<int> > res;
        if (!root) return res;

        sum -= root->val;
        path.push_back(root->val);

        if ( sum == 0  && root->left == nullptr && root->right == nullptr ) {
            res.push_back(path);
        }

        if (root->left)  PathGet( root->left, sum );
        if (root->right)  PathGet( root->right, sum );

        path.pop_back();
        return res;
    }
    void GetAllPath() {
//        std::vector< std::vector<int> > res = PathGet(g_pBstTree, 100);

    }
};

void tst_hasPathSum() {
    PrintInorder(g_pBstTree);

    bool bret = hasPathSum(g_pBstTree, 100);
    std::cout << "bret=" << bret << std::endl;
}

/*
    113. 路径总和 II
    给定一个二叉树和一个目标和，找到 `所有` 从根节点到叶子节点 路径总和 等于给定目标和的路径。

    说明: 叶子节点是指没有子节点的节点。

    示例: 给定如下二叉树，以及目标和 sum = 22，
                  5
                 / \
                4   8
               /   / \
              11  13  4
             /  \    / \
            7    2  5   1
    返回:
    [
       [5,4,11,2],
       [5,8,4,5]
    ]

-----------------------------------------------------------------------
注意到本题的要求是，找到所有满足从「根节点」到某个「叶子节点」经过的路径上的节点之和等于目标和的路径。
核心思想是对树进行一次遍历，在遍历时记录从根节点到当前节点的路径和，以防止重复计算。
-----------------------------------------------------------------------
*/
class CFindAllPaths {
    std::vector< std::vector<int> > res_;
    std::vector<int> tmp_;

    void preorder_traversal(BstNode *root, int sum) {
        if (!root) return;

        sum -= root->val;
        tmp_.push_back(root->val);

        if (nullptr == root->left && nullptr == root->right && sum == 0) {
            res_.push_back(tmp_);
        }

        preorder_traversal(root->left, sum);
        preorder_traversal(root->right, sum);
        tmp_.pop_back();
    }
public:
    void pathSum(BstNode *root, int sum) {
        if (!root) return;
        preorder_traversal(root, sum);
    }
};


/*
    477. 汉明距离总和
    两个整数的 汉明距离 指的是这两个数字的二进制数对应位不同的数量。

    计算一个数组中，任意两个数之间汉明距离的总和。

    示例:
    输入: 4, 14, 2
    输出: 6

    解释: 在二进制表示中，4表示为0100，14表示为1110，2表示为0010。（这样表示是为了体现后四位之间关系）
    答案：
    4   0100
    14  1110
    2   0010
    HammingDistance(4, 14) + HammingDistance(4, 2) + HammingDistance(14, 2) = 2 + 2 + 2 = 6
*/
int totalHammingDistance(const std::vector<int>& nums) {
    if (!nums.size()) return 0;

    int sz = nums.size(), res = 0;
    int flag = 1;
    for (int bit = 0; bit < 32; bit++)
    {
        int ones = 0;
        for (int i = 0; i < sz; i++)
        {
            ones += (nums[i] & flag) ? 1 : 0;
        }
        res += (sz - ones) * ones;
        flag <<= 1;
    }
    return res;
}
void Test_totalHammingDistance() {
    std::vector<int> v1{4, 14, 2};
    std::cout << "total hanming distance=" << totalHammingDistance(v1) << std::endl;
}

/*
    198. 打家劫舍
你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下，一夜之内能够偷窃到的最高金额。

示例 1：
输入：[1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

示例 2：
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
*/
int rob(vector<int> &nums) {

    return 0;
}
void Test_rob() {

}

/*
    338. 比特位计数
    给定一个非负整数 num。
    对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。

    示例 1:
    输入: 2
    输出: [0,1,1]

    示例 2:
    输入: 5
    输出: [0,1,1,2,1,2]

    进阶:
    给出时间复杂度为O(n*sizeof(integer))的解答非常容易。但你可以在线性时间O(n)内用一趟扫描做到吗？
    要求算法的空间复杂度为O(n)。
    你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount）来执行此操作。


-----------------------------------------------------------------------
    思路
对于所有的数字，只有两类：

奇数：二进制表示中，奇数一定比前面那个偶数多一个 1，因为多的就是最低位的 1。
          举例： 
         0 = 0       1 = 1
         2 = 10      3 = 11
偶数：二进制表示中，偶数中 1 的个数一定和除以 2 之后的那个数一样多。因为最低位是 0，除以 2 就是右移一位，也就是把那个 0 抹掉而已，所以 1 的个数是不变的。
           举例：
          2 = 10       4 = 100       8 = 1000
          3 = 11       6 = 110       12 = 1100
另外，0 的 1 个数为 0，于是就可以根据奇偶性开始遍历计算了。
-----------------------------------------------------------------------
*/
vector<int> countBits(int num) {
    vector<int> res(num + 1);
    res[0] = 0;
    for (int i = 1; i <= num; i ++) {
         
         if ((i % 2) == 1 ) { // ji shu
             res[i] = res[i - 1] + 1;
         }
         else
         { // ou shu
            res[i] = res[ i / 2 ];
         }
    }
    return res;
}


/*
    191. 位1的个数
    编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。

    进阶： 如果多次调用这个函数，你将如何优化你的算法？

    示例 1：
    输入：00000000000000000000000000001011
    输出：3
    解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

    示例 2：
    输入：00000000000000000000000010000000
    输出：1
    解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。

    示例 3：
    输入：11111111111111111111111111111101
    输出：31
    解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。

    -----------------------------------------------------------------------
    复杂度分析

    时间复杂度：O(1)。
    运行时间与 n 中位为 1 的有关。
    在最坏情况下， n 中所有位都是 1 。对于 32 位整数，运行时间是 O(1) 的。

    空间复杂度：O(1)。
    -----------------------------------------------------------------------
*/
int hammingWeight(uint32_t n) {
    if (!n) return 0;
    int count = 0;
    while (n) {
        count++;
        n = n & (n - 1);
    }
    return count;
}
void Test_hanmingWeight() {
    std::cout << "hanming weight=" << hammingWeight(3) << std::endl;
}

/*
    70. 爬楼梯

    假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
    每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
    注意：给定 n 是一个正整数。

    示例 1：
    输入： 2
    输出： 2
    解释： 有两种方法可以爬到楼顶。
    1.  1 阶 + 1 阶
    2.  2 阶

    示例 2：
    输入： 3
    输出： 3
    解释： 有三种方法可以爬到楼顶。
    1.  1 阶 + 1 阶 + 1 阶
    2.  1 阶 + 2 阶
    3.  2 阶 + 1 阶
-----------------------------------------------------------------------
思路:f(n) = f(n-1) + f(n-2)
下一步要到达第n级阶梯, 只有通过两种方式:
一 是从第n-1阶跨1阶到达
二 是从第n-2阶跨2阶到达，而到达n-1阶和n-2阶的组合数分别为dp(n-1)和dp(n-2)，加起来则为到达n阶的结果
-----------------------------------------------------------------------
*/
int climbStairs(int n) {
    {
        if ( n <= 2 ) return n;
        int a = 1;
        int b = 2, c = 0;
        for ( int i = 3; i < n; i ++ ) {
            c = a + b;
            a = b;
            b = c;
        }
        return c;
    }
}
void Test_climbStairs() {
    std::cout << "climb Stairs=" << climbStairs(13) << std::endl;
}


/*
    剑指 Offer 10- I. 斐波那契数列
    写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项。斐波那契数列的定义如下：

    F(0) = 0, F(1) = 1
    F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
    斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

    答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

    示例 1：
    输入：n = 2
    输出：1

    示例 2：
    输入：n = 5
    输出：5
*/
int fib(int n)
{
    {
        if ( 0 == n ) return 0;
        if ( 1 == n ) return 1;

        int n1 = 0, n2 = 1, sum = 0;
        while ( n >= 2 )  {
            sum = ( n1 + n2 ) % 1000000007;
            n1 = n2;
            n2 = sum;
            n --;
        }
        return sum;
    }
}
void tst_fib() {
    std::cout << "fib result=" << fib(11) << std::endl;
}

/*
    剑指 Offer 04. 二维数组中的查找
    在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。
    请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

    示例: 现有矩阵 matrix 如下：
    [
        [1,   4,  7, 11, 15],
        [2,   5,  8, 12, 19],
        [3,   6,  9, 16, 22],
        [10, 13, 14, 17, 24],
        [18, 21, 23, 26, 30]
    ]
    给定 target = 5， 返回 true。
    给定 target = 20，返回 false。

    -----------------------------------------------------------------------
    复杂度分析：
    时间复杂度 O(M+N)：其中，N 和 M 分别为矩阵行数和列数，此算法最多循环 M+N 次。
    空间复杂度 O(1): i, j 指针使用常数大小额外空间。
    -----------------------------------------------------------------------
*/
bool findNumberIn2DArray(vector<vector<int>> &matrix, int target)
{
    int i = matrix.size() - 1;
    int j = 0;
    while (i >= 0 && j < matrix[0].size()) {
        if (matrix[i][j] == target) return true;
        else if (matrix[i][j] > target) i --;
        else if (matrix[i][j] < target) j ++;
    }
    return false;
}
void Test_findNumberIn2DArray() {
}

/*
    322. 零钱兑换
    给定不同面额的硬币 coins 和一个总金额 amount。
    编写一个函数来计算 可以凑成总金额所需 最少的硬币个数。
    如果没有任何一种硬币组合能组成总金额，返回 -1。

    示例 1：
    输入：coins = [1, 2, 5], amount = 11
    输出：3 
    解释：11 = 5 + 5 + 1

    示例 2：
    输入：coins = [2], amount = 3
    输出：-1

    示例 3：
    输入：coins = [1], amount = 0
    输出：0

    示例 4：
    输入：coins = [1], amount = 1
    输出：1

    示例 5：
    输入：coins = [1], amount = 2
    输出：2
*/
int coinChange(vector<int>& coins, int amount) {

    return 0;
}
void Test_coinChange() {
    std::vector<int> v1{1, 2, 5};
    std::cout << "ret=" << coinChange(v1, 11) << std::endl;
}


/*
    搜索插入位置
    给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
    你可以假设数组中无重复元素。

    示例 1:
    输入: [1,3,5,6], 5
    输出: 2

    示例 2:
    输入: [1,3,5,6], 2
    输出: 1

    示例 3:
    输入: [1,3,5,6], 7
    输出: 4

    示例 4:
    输入: [1,3,5,6], 0
    输出: 0

-----------------------------------------------------------------------
复杂度分析：以后大家「只要看到面试题里给出的数组是有序数组，都可以想一想是否可以使用二分法。」
同时题目还强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下表可能不是唯一的。

时间复杂度：
空间复杂度：
-----------------------------------------------------------------------
*/
int searchInsert(vector<int>& nums, int target) {
    {
        int left = 0;
        int right = nums.size() - 1;

        while ( left < right )  {

            int mid = left + ((right - left) >> 1);

            if ( nums[ mid ] > target ) {
                right = mid; // target 在左区间，在[left, middle)中
            } else if ( nums [ mid ] < target ) {
                left = mid + 1; // target 在右区间，在 [middle+1, right)中
            } else { // ==
                return mid; // 数组中找到目标值的情况，直接返回下标
            }
        }
        // 分别处理如下四种情况
        // 目标值在数组所有元素之前 [0,0)
        // 目标值等于数组中某一个元素 return mid
        // 目标值插入数组中的位置 [left, right) ，return right 即可
        // 目标值在数组所有元素之后的情况 [left, right)，return right 即可
        return left;
    }

}
void tst_searchInsert() {
    std::vector<int> a { 1,3,5,6 };
    std::cout << "insert pos1=" << searchInsert(a, 2) << std::endl;
    std::cout << "insert pos2=" << searchInsert(a, 7) << std::endl;
}

/*
    365. 水壶问题
    有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？

    如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。

    你允许：
    装满任意一个水壶
    清空任意一个水壶
    从一个水壶向另外一个水壶倒水，直到装满或者倒空

    示例 1: (From the famous "Die Hard" example)
    输入: x = 3, y = 5, z = 4
    输出: True

    示例 2:
    输入: x = 2, y = 6, z = 5
    输出: False
*/
bool canMeasureWater(int x, int y, int z) {

        return true;
}

/*
    剑指 Offer 37. 序列化二叉树
    请实现两个函数，分别用来序列化和反序列化二叉树。

    示例: 你可以将以下二叉树：

         1
        / \
       2   3
          / \
         4   5

    序列化为 "[1,2,3,null,null,4,5]"
*/
class Codec {
public:

    // Encodes a tree to a single string.
    std::string serialize(BstNode* root) {

        {
            std::queue<BstNode*> que;
            que.push(root);

            std::ostringstream out;
            while (que.size()) {
                
                BstNode *tmp = que.front();
                que.pop();

                if (tmp) {
                    out << " " << tmp->val;
                    que.push(tmp->left);
                    que.push(tmp->right);
                } else {
                    out << " null ";
                }

            }// end while ---
            return out.str();
        }

    }

    // Decodes your encoded data to tree.
    BstNode* deserialize(std::string data) {
        std::istringstream input(data);

        return nullptr;
    }
};
void Test_BstCodec() {

    std::cout << std::endl;
    PrintInorder(g_pBstTree);
    std::cout << std::endl;
    // return;

    Codec c;
    auto str = c.serialize(g_pBstTree);
    std::cout << "str=" << str << std::endl;
    return ;

    std::ostringstream out;
    out << " "; out << 123;
    out << " "; out << 991;
    out << " "; out << "null";
    out << " "; out << 6677;
    out << " "; out << "null";

    std::cout << "beg --------------------" << std::endl;
    std::istringstream input(out.str());
    string val;
    while (input >> val) {
        // if (val == " ")
        //     std::cout << " find \" \"" << std::endl;
        std::cout << val << std::endl;
    }
    std::cout << "end --------------------" << std::endl;
}



/*
    39. 组合总和
    给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。

    candidates 中的数字可以无限制重复被选取。

    说明： 所有数字（包括 target）都是正整数。 解集不能包含重复的组合。

    示例 1：
    输入：candidates = [2,3,6,7], target = 7,
    所求解集为：
    [
        [7],
        [2,2,3]
    ]

    示例 2：
    输入：candidates = [2,3,5], target = 8,
    所求解集为：
    [
        [2,2,2,2],
        [2,3,3],
        [3,5]
    ]
-----------------------------------------------------------------------
-----------------------------------------------------------------------
*/
vector<vector<int>> combinationSum(vector<int> &candidates, int target) {
    vector<vector<int>> result;

    return result;
}

void Test_combinationSum()
{
}



/*
    238. 除自身以外数组的乘积
    给你一个长度为 n 的整数数组 nums，其中 n > 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。

    示例:
    输入: [1,2,3,4]
    输出: [24,12,8,6]

    提示: 题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。
    说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。
    进阶: 你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）
-----------------------------------------------------------------------
-----------------------------------------------------------------------
*/
vector<int> productExceptSelf(vector<int> &nums) {

    int length = nums.size();
    std::vector<int> ans(length);

    // ans[i] 表示索引 i 左侧所有元素的乘积
    // 因为索引为 '0' 的元素左侧没有元素， 所以 ans[0] = 1
    ans[0] = 1;
    for (int i = 1; i < length; i++) {
        ans[i] = nums[i - 1] * ans[i - 1];
    }
    
    // R 为右侧所有元素的乘积
    // 刚开始右边没有元素，所以 R = 1
    int R = 1;
    for (int i = length - 1; i >= 0; i++) {
        ans[i] = ans[i] * R;
        // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上
        R *= nums[i];
    }

    return ans;
}
void Test_productExceptSelf() {
    std::vector<int> v1{1, 2, 3, 4};
    auto ret1 = productExceptSelf(v1);

    PrintInContainer(ret1);
}

/*
    48. 旋转图像
    给定一个 n × n 的二维矩阵表示一个图像。
    将图像顺时针旋转 90 度。
    说明：你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。

    示例 1:
    给定 matrix = 
    [
        [1,2,3],
        [4,5,6],
        [7,8,9]
    ],
    原地旋转输入矩阵，使其变为:
    [
        [7,4,1],
        [8,5,2],
        [9,6,3]
    ]

    示例 2:
    给定 matrix =
    [
        [ 5, 1, 9,11],
        [ 2, 4, 8,10],
        [13, 3, 6, 7],
        [15,14,12,16]
    ], 
    原地旋转输入矩阵，使其变为:
    [
        [15,13, 2, 5],
        [14, 3, 4, 1],
        [12, 6, 8, 9],
        [16, 7,10,11]
    ]
*/
void rotateMatrix(vector<vector<int>>& matrix) {
    
}
void Test_rotateMatrix() {

}

/*
    96. 不同的二叉搜索树
    给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

    示例:
    输入: 3
    输出: 5
    解释: 给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

        1         3     3      2      1
        \       /     /      / \      \
        3     2     1      1   3      2
        /     /       \                 \
        2     1         2                 3

*/
int numTrees(int n) {

    return 1;
}
void Test_numTrees() {

}

/*
    208. 实现 Trie (前缀树)
    实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。

    示例:
    Trie trie = new Trie();
    trie.insert("apple");
    trie.search("apple");   // 返回 true
    trie.search("app");     // 返回 false
    trie.startsWith("app"); // 返回 true
    trie.insert("app");   
    trie.search("app");     // 返回 true

    说明:
    你可以假设所有的输入都是由小写字母 a-z 构成的。
    保证所有输入均为非空字符串。
*/
class Trie {
    bool isEnd;
    Trie* next[26];

public:
    /** Initialize your data structure here. */
    Trie() {
        isEnd = false;
        memset(next, 0, sizeof(next));
    }

    /** Inserts a word into the trie. */
    void insert(string word) {
    }
    
    /** Returns if the word is in the trie. */
    bool search(string word) {
        return true;
    }

    /** Returns if there is any word in the trie that starts with the given prefix. */
    bool startsWith(string prefix) {
        return true;
    }
};

/*
    Trie树 可用于解决类似 以下面试题：
    给你100000个长度不超过10的单词。对于每一个单词，我们要判断他出没出现过，如果出现了，求第一次出现在第几个位置。
    有一个1G大小的文件，里面每一行是一个词，词的大小不超过16字节，内存限制大小是1M，求频数最高的100个词1000万字符串，其中有些是重复的，需要把重复的全部去掉，保留没有重复的字符串，请问怎么设计和实现？
    一个文本文件，大约有一万行，每行一个词，要求统计出其中最频繁出现的前10个词，请给出思想，给出时间复杂度分析。
*/

/*
    给你100000个长度不超过10的单词。对于每一个单词，我们要判断他出没出现过，如果出现了，求第一次出现在第几个位置

    使用trie：因为当查询如字符串abc是否为某个字符串的前缀时，显然以b,c,d....等不是以a开头的字符串就不用查找了。
    所以建立trie的复杂度为O(n*len)，而建立+查询在trie中是可以同时执行的，
    建立的过程也就可以称为查询的过程，hash就不能实现这个功能。
    所以总的复杂度为O(n*len)，实际查询的复杂度也只是O(len)。
   （说白了，就是Trie树的平均高度h为len，所以Trie树的查询复杂度为O（h）=O（len）。
    好比一棵二叉平衡树的高度为logN，则其查询，插入的平均时间复杂度亦为O（logN））。
*/

struct TrieNode {
    bool flag;
    TrieNode* children_[26];
    TrieNode() {
        flag = false;
        for ( int i = 0; i < 26; i ++ ) {
            children_[i] = nullptr;
        }
    }
};

class TrieTree {
public:
    TrieTree() {

    }
    ~TrieTree() {
    }
    void insert(std::string word) {// build the Trie
        TrieNode* p = root_;
        for ( auto cur : word ) {
            int val = cur - 'a';
            if (p->children_[val] == nullptr) {
                p->children_[val] = new TrieNode();
            }
            p = p->children_[val];
        }
        p->flag = true;
    }
    bool search(std::string word) {// search in the Trie
        TrieNode* p = root_;
        for ( auto cur : word ) {
            int val = cur - 'a';
            if (p->children_[val] == nullptr) {
                return false;
            }
            p = p->children_[val];
        }
        return p->flag;
    }
    bool startWith(std::string word) {

        TrieNode* p = root_;
        for ( size_t i = 0; i < word.size(); i ++ ) {

            int val = (int)(word[i] - 'a');

            if (p->children_[val] == nullptr) {
                return false;
            }
            p = p->children_[val];
        }
        return true;
    }
public:
/*
    给定一个不含重复单词的列表，编写一个程序，返回给定单词列表中所有的连接词。
    连接词定义: 一个字符串完全是由至少两个给定数组中的单词组成的。
    示例:
    输入: ["cat","cats","catsdogcats","dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"]
    输出: ["catsdogcats","dogcatsdog","ratcatdogcat"]

    解释: "catsdogcats"由"cats", "dog" 和 "cats"组成;
         "dogcatsdog"由"dog", "cats"和"dog"组成;
         "ratcatdogcat"由"rat", "cat", "dog"和"cat"组成。
*/
    std::vector<std::string> findAllConcatenatedWordsInADict(vector<string>& words) {

        std::vector<string> res;
        root_ = new TrieNode();

        auto cmp = [](const std::string& a, const std::string& b) {
            if (a.length() != b.length()) {
                return a.length() < b.length();
            }
            return a < b;
        };
        std::sort(words.begin(), words.end(), cmp);

        for(size_t i=0; i<words.size(); ++i) {
            auto word = words[i];
            if (dfs(word)) {
                res.emplace_back(word);
            }
            insert(word);
        }
        return res;
    }
    bool dfs(std::string word) {
        std::string before;
        for (size_t i = 0; i < word.size(); i ++ ) {

            before += word[i];
            std::string after = word.substr(i+1);

            if ( search(before) && after != "" ) {
                if ( search(after) || dfs(after) ) {
                    return true;
                }
            }

        }// for --- end ---
        return false;
    }

    void tst_str_v() {

        {
//            std::string str;
//            std::string word = "12345";
//            for (size_t i = 0; i < word.size(); i ++ ) {
//                str += word[i];
//                std::string after = word.substr(i+1);
//                std::cout << "str=" << str << ", after=" << after << std::endl;
//            }
//            return;
        }
        std::vector<std::string> v_str{"cat","cats","catsdogcats", "dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"};
//        std::vector<std::string> v_str{"vtx", "x-ray", "cat","cats","catsdogcats", "vvdy", "zxv", "dog","dogcatsdog","hippopotamuses","rat","ratcatdogcat"};
        auto cmp = [](const std::string& a, const std::string& b) {
//            return a < b;
            return a.length() < b.length();
        };

        std::sort(v_str.begin(), v_str.end(), cmp);
        for (auto str : v_str) {
            std::cout << " " << str;
        }
        std::cout << std::endl;

        auto res = findAllConcatenatedWordsInADict(v_str);
        for (auto c : res) {
            std::cout << " " << c;
        }
        std::cout << std::endl;
    }
private:
    TrieNode* root_;
};




class CnTrieNode {
public:
    CnTrieNode() : count_(0) {
    }
    int count_;// 以当前节点结尾的字符串的个数
    std::map<char16_t, CnTrieNode*> childs_;
};

class CnTrieTree {
public:
    CnTrieTree() { root_ = new CnTrieNode(); }
    void insert_string(const u16string& str);
    vector<u16string> get_str_pre(const u16string& str);

private:// 辅助函数
    void add_str(CnTrieNode* preNode, u16string str, vector<u16string>& ret);
    CnTrieNode* search_str_pre(const u16string& str);

private:
    CnTrieNode* root_;
};

void CnTrieTree::insert_string(const u16string& str) {
    if (str.empty()) {
        return;
    }

    CnTrieNode* curNode = root_;
    for (auto& chr : str) {
//        std::cout << "chr=" << chr << std::endl;

        auto iter = curNode->childs_.find(chr);
        if (iter == curNode->childs_.end()) {
            CnTrieNode* newNode = new CnTrieNode;
            curNode->childs_.insert(make_pair(chr, newNode));
            curNode = newNode;
        } else {
            curNode = iter->second; //如果当前字符在字典书中，则将当前节点指向它的孩子
        }

    } // end --- for...
    if (curNode)
        curNode->count_ ++;
}

//查找以str为前缀的节点
CnTrieNode* CnTrieTree::search_str_pre(const u16string& str) {
    if (str.empty()) {
        return nullptr;
    }

    CnTrieNode* curNode = root_;
    for (auto& chr : str) {

        auto iter = curNode->childs_.find(chr);
        if (iter != curNode->childs_.end()) {
            curNode = iter->second;
        } else {
            return nullptr;
        }

    } // end --- for...

    return curNode;
}

vector<u16string> CnTrieTree::get_str_pre(const u16string& str) {
    vector<u16string> ret;

    CnTrieNode* pre = search_str_pre(str);
    if (pre)
    {
        add_str(pre, str, ret);
    }
    return ret;
}

void CnTrieTree::add_str(CnTrieNode* preNode, u16string str, vector<u16string>& ret) {
    for (auto Iter = preNode->childs_.begin(); Iter != preNode->childs_.end(); ++Iter)
    {
        add_str(Iter->second, str + Iter->first, ret);
    }
    if (preNode->count_)
        ret.push_back(str);
}


void Tst_TireTree() {

    {
        setlocale(LC_ALL, "");

        std::vector<u16string> hotwords = { u"杨文婷",u"联系",u"杨洋洋",u"杨sir大警官",u"杨y文w婷t",u"杨文婷是小学生",
            u"杨钰莹",u"杨文婷ywt是小学生",u"联系a群众",u"阳光么",u"阳光明媚",u"ywt是小学生",u"联系ywt",u"杨文t爱吃面",u"杨文婷妹妹",
            u"杨光明眉",u"小学生",u"杨文婷爱吃面",u"我是小学生",u"我是中国人",u"ywt要吃面",u"y杨文婷",u"有问题" };

        hotwords = { u"cat",u"dogs",u"cat dogs",u"dog cats",u"monkeycat",u"monkeydog" };

        CnTrieTree ctt;
        for (auto& word : hotwords) {
            ctt.insert_string(word);
        }

//        vector<u16string> res = ctt.get_str_pre(u"杨");
//        vector<u16string> res = ctt.get_str_pre(u"杨文婷");
        vector<u16string> res = ctt.get_str_pre(u"cat");

        for (auto& resString : res)
        {
            for (auto& chr : resString)
            {
                printf("%lc", chr);
            }
            printf("\n");
        }

//        getchar();
        return;
    }


    TrieTree tt;
    tt.tst_str_v();
    return;

    tt.insert("ji");
    tt.insert("nanchi");
    tt.insert("nanren");

    std::cout << "search ji=" << tt.search("ji") << std::endl;
    std::cout << "star with=" << tt.startWith("nan") << std::endl;
}

class CSomeNode {
    int val_;
public:
    CSomeNode(int val) : val_(val){
        std::cout << "cst CSomeNode, val=" << val_ << std::endl;
    }
    ~CSomeNode() {
        std::cout << "~dst CSomeNode, val=" << val_ << std::endl;
    }

public:
    std::shared_ptr<CSomeNode> leftPtr;
    std::shared_ptr<CSomeNode> rightPtr;
    std::weak_ptr<CSomeNode> parentPtr;
};



class CBase1 {
public:
    int b1;
    CBase1() {
        b1 = 1;
    }
    ~CBase1(){

    }
    virtual  void fun1() {}
};

class CD1 : public CBase1 {
public:
    int d1;
    CD1() {
        d1 = 11;
    }
    ~CD1(){

    }
    virtual  void fun1() {}
};

class Attt
{
public:
    Attt(int v)// : var(v)
    {
        file = fopen("test", "r");
    }
    ~Attt()
    {
        fclose(file);
    }

private:
//    int var;
    FILE *file;
};


void tstsomeNode() {
    Tst_TireTree(); return;

    {
        Attt ao(123);
        std::cout << "sizeof(ao)=" << sizeof(ao) << std::endl;
        return ;
    }
    {
        CD1 cd;
        std::cout << "sizeof(cd)=" << sizeof(cd) << std::endl;
        return ;
    }
    {
            std::shared_ptr<CSomeNode> root = std::make_shared<CSomeNode>(3);

            root->leftPtr = std::make_shared<CSomeNode>(2);
            root->leftPtr->parentPtr = root;

            root->rightPtr = std::make_shared<CSomeNode>(4);
            root->rightPtr->parentPtr = root;

            std::cout << "root use count=" << root.use_count() << std::endl;
            std::cout << "left use count=" << root->leftPtr.use_count() << std::endl;
            std::cout << "right use count=" << root->rightPtr.use_count() << std::endl;
    }
    std::cout << "---------------------------------------------" << std::endl;
    {
        std::shared_ptr<CSomeNode> node = std::make_shared<CSomeNode>(13);
        std::weak_ptr<CSomeNode> wknode = node;

        std::shared_ptr<CSomeNode> ptr_2 = wknode.lock();
//        if (node2)
//            std::cout << (*node2) << std::endl;

        std::cout << "reference Count = " << ptr_2.use_count() << std::endl;

        if (wknode.expired() == false) {
            std::cout << "Not expired yet" << std::endl;
        }
    }
}

void tstLingxingDerive() {

    class A
    {
    public:
        A():a(1){};
        void printA(){cout<<a<<endl;}
        int a;
    };

    class B : virtual public A
    {
    };

    class C : virtual public A
    {
    };

    class D:  public B ,  public C
    {
    };


    D d;
    std::cout << "sizeof(d)=" << sizeof(d) << std::endl;

}


bool fun1(const std::string& str, std::string::size_type l) {
    return str.size() < l;
}
void tst_vector() {

    std::vector<string> v{"11","2222222","3","44444444","555","66","777777"} ;

    std::stable_sort(v.begin(), v.end(), [](const string &a ,const string &b) {
        return a.size() < b.size();
    });

    for_each(v.begin(), v.end(), [](const std::string& str) {
        std::cout << " " << str;
    });
    std::cout << std::endl;

    int num1 = std::count_if(v.begin(), v.end(), std::bind(fun1, std::placeholders::_1, 6));
    std::cout << "num1=" << num1 << std::endl;

}

class CHeapSort {
public:
    // 构造 大顶堆
    // 每个节点堆化的时间复杂度是：O(logN)
    void heapify(vector<int>& a, int n, int i) {

        while (true) {
            int maxPos = i;

            if ( (i*2 + 1) <= n && a[i] < a[i*2 + 1] ) { // 左子节点，就是下标为 i∗2+1 的节点
                maxPos = i*2 + 1;
            }
            if ( (i*2 + 2) <= n && a[maxPos] < a[i*2 + 2] ) {// 右子节点，就是下标为 i∗2+2 的节点
                maxPos = i*2 + 2;
            }

            if (maxPos == i)
                break;

            std::swap(a[maxPos], a[i]);
            i = maxPos;
        }// end --- for
    }
    void buildHeap(std::vector<int>& arr, int n) {// 时间复杂度：O(N)

        for ( int i = n/2 -1; i >= 0; i -- ) {// 从后向前，非叶子节点是：0 到 n/2-1
            heapify(arr, n, i);
        }
    }

    std::vector<int> sortArr(std::vector<int>& nums) {
        if (nums.size() <= 0) return nums;

//        PrintInContainer(nums);
        buildHeap(nums, nums.size() - 1);

        int k = nums.size() - 1;
        while (k) {
            std::swap(nums[k], nums[0]);
            k--;
            heapify(nums, k, 0);
        }
        return nums;
    }
//    以上下标是从0开始。如果是以1开始的话，那么左子树，右子树下标就不一样了
//    堆排分为两步(建堆O(n)+排序(O(NlogN))),所以总的时间复杂度是O(NlogN)
//    不稳定，空间复杂度是O(1)
};

void tst_heap_sort_1() {

    std::vector<int> arr { 9816, 13, 4, 1, 21, -13 };

    CHeapSort cs;
    auto res = cs.sortArr(arr);

    PrintInContainer(res);
}

class MergeSort {
public:

    void merge_two(vector<int>& nums, int left, int mid, int right, vector<int>& tmp) {

        int k = 0;//临时数组下标
        int i = left;//左边数组的起始
        int j = mid + 1;//右边数组的起始

        while (i <= mid && j <= right)
        {
//            std::cout << "i=" << i << ", j=" << j << ", mid=" << mid << ", right=" << right << std::endl;
            if (nums[i] <= nums[j])
                tmp[k++] = nums[i++];
            else
                tmp[k++] = nums[j++];
        }
        while (i <= mid) {
            tmp[k++] = nums[i++];
        }
        while (j <= right) {
            tmp[k++] = nums[j++];
        }
        std::copy_n(tmp.begin(), k, nums.begin() + left);
    }
    void merge_sort(std::vector<int>& nums, int left, int right, std::vector<int>& tmp) {

        if (left >= right) return;

        int mid = (left + right)>>1;
        std::cout << mid << " " << std::endl;
//        int mid = left + ((right - left) >> 1);
        merge_sort(nums, left, mid, tmp);
        merge_sort(nums, mid+1, right, tmp);

        merge_two(nums, left, mid, right, tmp);
    }
    std::vector<int> sortArray(std::vector<int>& nums) {
        if (nums.size() == 0) return nums;

        std::vector<int> tmp(nums.size());
        merge_sort(nums, 0, nums.size()-1, tmp);
        return nums;
    }
};
void tst_merge_sort_2() {
    std::vector<int> arr { 9816, 13, 4, 1, 21, -13 };
    std::cout << "size=" << array_size(arr) << std::endl;

    MergeSort ms;
    auto res = ms.sortArray(arr);

    PrintInContainer(res);
}


class InsertSort {

public:
    void insertSort(vector<int>& nums) {

        for (int i = 1; i < nums.size(); i ++ ) {

            int key = nums[i];
            int j = i - 1;

            for (; j >= 0; j --) {// 查找插入位置

                if (nums[j] > key) {
                    nums[j + 1] = nums[j];
                } else {
                    break;
                }

            } // end --- for
            nums[j + 1] = key;
        }// end --- for
    }
};
void tst_insert_sort_2() {
    std::vector<int> arr { 9816, 13, 4, 1, 21, -13 };
    std::cout << "size=" << array_size(arr) << std::endl;

    InsertSort is;
    is.insertSort(arr);

    PrintInContainer(arr);
}

/*
    剑指 Offer 11. 旋转数组的最小数字
    把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。

    示例 1：
    输入：[3,4,5,1,2]
    输出：1

    示例 2：
    输入：[2,2,2,0,1]
    输出：0
-----------------------------------------------------------------------
复杂度分析：
时间复杂度：平均时间复杂度为 O(logn)，其中 n 是数组 numbers 的长度。
如果数组是随机生成的，那么数组中包含相同元素的概率很低，在二分查找的过程中，大部分情况都会忽略一半的区间。
而在最坏情况下，如果数组中的元素完全相同，那么 while 循环就需要执行 nn 次，每次忽略区间的右端点，时间复杂度为 O(n)。

空间复杂度：O(1)
-----------------------------------------------------------------------
*/
int minArray(vector<int>& numbers) {
    int l = 0, r = numbers.size() - 1;

    while ( l < r ) {

        int mid =  l +  ( ( r - l )  >> 1);

        if  ( numbers [ mid ] > numbers[ r ] ) {
            l = mid + 1;
        } else  if  ( numbers [ mid ] < numbers[ r ] )  {
            r = mid;
        } else {
            r --;
        }
    }

    return numbers[ l ];
}
void tst_minArray() {
    std::vector<int> arr1 { 4,5,6,7,0,1,2 };
    std::cout << "minVal=" << minArray(arr1) << std::endl;

    std::vector<int> arr2 { 315, 455, 987, 2048, -13, 1 };
    std::cout << "minVal=" << minArray(arr2) << std::endl;
}


/*
    剑指 Offer 53 - I. 在排序数组中查找数字 I

    统计一个数字在 排序数组中 出现的次数。
    示例 1:
    输入: nums = [5,7,7,8,8,10], target = 8
    输出: 2

    示例 2:
    输入: nums = [5,7,7,8,8,10], target = 6
    输出: 0
-----------------------------------------------------------------------
复杂度分析：
-----------------------------------------------------------------------
*/
int findNumCount(vector<int>& nums, int target) {

    {
        int count = 0;
        if (nums.empty()) return 0;
        int mid = -1;
        int left = 0, right = nums.size() - 1;

        while ( left < right ) {// confirm left ...

            mid = left + ((right - left) >> 1);

            if ( nums[ mid ] >= target ) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        if ( nums[ left ] != target ) return 0;

        for ( int t = left; t < nums.size(); t ++ ) {
            if ( nums[ t ] == target ) {
                count ++;
            }
        }
        return count;
//        while ( left < right ) {// confirm right ...

//            mid = left + ((right - left) >> 1);

//            if ( nums [ mid ] <= target ) {
//                left = mid + 1;
//            } else {
////                right =
//            }
//        }
        return -1;
    }

    int mid = 0;
    int left = 0, right = nums.size() - 1;

    while (left < right) {

        mid = left + ((right - left) >> 1);

        if ( nums[ mid ] >= target ) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    if (nums[left] != target) return -1;

    int x = left;
    right = nums.size() - 1;
    while (left < right) {

        mid = left + ((right - left) >> 1);

        if ( nums[ mid ] <= target ) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }

    return left - x;
}
void tst_findNumCount() {
//    std::vector<int> arr { 315, 455, 987, 2048, 2048, 2048, 2048, 2048, 2048, 9981 };
    std::vector<int> arr{ 5,7,7,8,8,10 };
    std::cout << "findNumCount=" << findNumCount(arr, 6) << std::endl;
}



/*
    剑指 Offer 53.2 —— 0~n-1中缺失的数字
    一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。
    在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。

    示例 1:
    输入: [0,1,3]
    输出: 2

    示例 2:
    输入: [0,1,2,3,4,5,6,7,9]
    输出: 8
-----------------------------------------------------------------------
复杂度分析：
如果 k == nums[k]，那么缺失的数字一定在 k 右边;
如果 k != nums[k]，那么缺失的数字要么为 k 要么在 k 左边;
这个很类似于二分查找，我们也可以使用二分的思想去优化时间复杂度。
-----------------------------------------------------------------------
*/
int missingNum(vector<int>& nums, int sz) {
    int left  = 0;
    int right = sz;

    while ( left <= right ) {
        int mid = left + ((right - left) >> 1);

        if (nums[ mid ] == mid) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return left;
}
void tst_missingNum() {
    int num = 1;
    string src = to_string(num);

    std::vector<int> arr { 0, 1, 2, 3, 4, 5, 7, 8, 9 };
    std::cout << "missingNum=" << missingNum(arr, arr.size()) << std::endl;
}



/*
    40. 组合总和 II
    给定一个数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。
    candidates 中的每个数字在每个组合中只能使用一次。
    说明：所有数字（包括目标数）都是正整数。解集不能包含重复的组合。

    示例 1:
    输入: candidates = [10,1,2,7,6,1,5], target = 8,
    所求解集为:
    [
      [1, 7],
      [1, 2, 5],
      [2, 6],
      [1, 1, 6]
    ]

    示例 2:
    输入: candidates = [2,5,2,1,2], target = 5,
    所求解集为:
    [
      [1,2,2],
      [5]
    ]
-----------------------------------------------------------------------
复杂度分析：
-----------------------------------------------------------------------
*/
vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {

    vector<vector<int>> res;

    return res;
}


/*
    102. 二叉树的层序遍历

    给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

    示例：
    二叉树：[3,9,20,null,null,15,7],
        3
       / \
      9  20
        /  \
       15   7

    返回其层序遍历结果：
    [
      [3],
      [9,20],
      [15,7]
    ]
-----------------------------------------------------------------------
复杂度分析：
-----------------------------------------------------------------------
*/
std::vector< std::vector<int> > levelOrderBst(BstNode* root) {

    std::vector< std::vector<int> > res;
    if (!root) return res;

    std::queue< BstNode* > queNodes;
    queNodes.push(root);

    while (!queNodes.empty()) {

        std::vector<int> vals;

        int sz = queNodes.size();
        for (int i = 0; i < sz; i ++) {

            BstNode* tmpNode = queNodes.front();
            queNodes.pop();

            if ( tmpNode->left ) {
                queNodes.push(tmpNode->left);
            }
            if ( tmpNode->right ) {
                queNodes.push(tmpNode->right);
            }

            vals.push_back(tmpNode->val);
        }

        res.push_back(vals);
    }

    return res;
}

/*
    LeetCode 题解 | 11. 盛最多水的容器/容器盛水问题

    给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。
    在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。
    找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。

    示例 1：
    输入：[1,8,6,2,5,4,8,3,7]
    输出：49
    解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。
    在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

    示例 2：
    输入：height = [1,1]
    输出：1

    示例 3：
    输入：height = [4,3,2,1,4]
    输出：16

    示例 4：
    输入：height = [1,2,1]
    输出：2

-----------------------------------------------------------------------
复杂度分析：
-----------------------------------------------------------------------
*/
int maxArea(vector<int>& height) {
    int l = 0, r = height.size() - 1;
    int res = -1;

    while ( l < r ) {
        int ares = std::min( height[l], height[r] ) * (r - l);
        res = std::max( ares, res );

        if ( height [ l ] <= height[ r ] )
            l ++;
        else
            r --;
    }
    return res;
}
void tst_maxArea() {
    std::vector<int> height { 1,8,6,2,5,4,8,3,7 };
    std::cout << "maxArea=" << maxArea(height) << std::endl;
}


/*
    617. 合并二叉树

    给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

    需要将他们合并为一个新的二叉树。
    合并规则: 如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，
    否则不为 NULL 的节点将直接作为新二叉树的节点。

    示例 1:
    输入:
        Tree 1                     Tree 2
              1                         2
             / \                       / \
            3   2                     1   3
           /                           \   \
          5                             4   7
    输出:
    合并后的树:
             3
            / \
           4   5
          / \   \
         5   4   7
    注意: 合并必须从两个树的根节点开始。
*/
TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) {
    if (t1 == nullptr) return t2;
    if (t2 == nullptr) return t1;
    t1->val += t2->val;
    t1->left = mergeTrees(t1->left, t2->left);
    t1->right = mergeTrees(t1->right, t2->right);
    return t1;
}


/*
    3. 无重复字符的最长子串
    给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

    示例 1:
    输入: s = "abcabcbb"
    输出: 3
    解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

    示例 2:
    输入: s = "bbbbb"
    输出: 1
    解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

    示例 3:
    输入: s = "pwwkew"
    输出: 3
    解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
         请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。

    示例 4:
    输入: s = ""
    输出: 0

-----------------------------------------------------------------------
复杂度分析：
                ----  滑动窗口
-----------------------------------------------------------------------
*/
size_t lengthOfLongestSubstringEx(string s) {
    {
        if (s.empty()) return 0;

        int map[ 128 ] = {0};
        size_t start = 0, len = 0;
        
        for ( size_t i = 0; i < s.size(); i ++ ) {
            ++ map[ s[i] ];
            
            while ( map[ s[i] ] > 1 ) {
                --map[ s[start++] ];
            }

            len = std::max(len, i - start + 1);
        }
        // for ( auto e : map ) {
        //     std::cout << " " << e;
        // }
        std::cout << " " << std::endl;
        return len;
    }

    {
    }
}
void tst_lengthOfLongestSubstringEx() {
    std::string str = "9987711";
    str = "998711";
    std::cout << "lenght_long_substr=" << lengthOfLongestSubstringEx(str) << std::endl;
}

// 给定一个数组arr，返回arr的最长无重复子串的长度(无重复指的是所有数字都不相同)。
int maxLength(std::vector<int>& arr) {

    {
        int ans = -1;
        int l = 0, r = 0;
        std::set<int> s;

        while ( r < arr.size() ) {
            if ( s.count(arr[ r ]) == 0 ) { // found element
                std::cout << "r=" << r << ", insert=" << arr[r] << std::endl;
                s.insert( arr[r++] );
            } else {
                std::cout << "l=" << l << ", remove=" << arr[l] << std::endl;
                s.erase( arr[l++] );
            }
            ans = ans > arr.size() ? ans: arr.size();
        }
        PrintInContainer(s);
        return ans;
    }

}
void tst_maxLength() {
    std::vector<int> vec{ 1, 3, 4, 5, 77, 77, 88, 90 };
    std::cout << "max sub string size=" << maxLength(vec) << std::endl;
//    PrintInContainer(vec);
}
    // int maxLength(vector<int>& arr) {
        
    //     int l = 0, r = 0, ans = 0;;
    //     std::set<int> s;

    //     while (r < arr.size()) {
    //         if ( !s.count(arr[r]) ) {
    //             s.insert(arr[r++]);
    //         } else{
    //             s.erase(arr[l++]);
    //         }
    //         ans = ans > s.size() ? ans : s.size();
    //     }
    //     return ans;
    // }


/*
    239. 滑动窗口最大值
    给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。
    你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
    返回滑动窗口中的最大值。

    示例 1：
    输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
    输出：[3,3,5,5,6,7]
    解释：
    滑动窗口的位置                最大值
    ---------------               -----
    [1  3  -1] -3  5  3  6  7       3
     1 [3  -1  -3] 5  3  6  7       3
     1  3 [-1  -3  5] 3  6  7       5
     1  3  -1 [-3  5  3] 6  7       5
     1  3  -1  -3 [5  3  6] 7       6
     1  3  -1  -3  5 [3  6  7]      7

    示例 2：
    输入：nums = [1], k = 1
    输出：[1]

    示例 3：
    输入：nums = [1,-1], k = 1
    输出：[1,-1]

    示例 4：
    输入：nums = [9,11], k = 2
    输出：[11]

    示例 5：
    输入：nums = [4,-2], k = 2
    输出：[4]
*/
vector<size_t> maxSlidingWindow(vector<int>& nums, size_t k) {

    size_t n = nums.size();
    std::priority_queue< pair<size_t, size_t> > pri_que;

    for ( size_t i = 0; i < k; i ++ ) {
        pri_que.emplace( nums[ i ], i );
    }
    {
        std::vector<size_t> ans { pri_que.top().first };
        for ( size_t j = k; j < n; j ++ ) {

            pri_que.emplace( nums[ j ], j );

            while ( pri_que.top().second >= j - k ) {
                pri_que.pop();
            }

            ans.push_back(pri_que.top().first);
        }
        return ans;
    }

    {
//        //    while ( pri_que.size() ) {
//        //        auto ele = pri_que.top();
//        //        std::cout << "first=" << ele.first << ", second=" << ele.second <<std::endl;
//        //        pri_que.pop();
//        //    }
//        //    return std::vector<int> {};

//        std::vector<int> ans{pri_que.top().first};

//        for ( auto j = k; j < n; j ++ ) {

//            pri_que.emplace( nums[ j ], j );

//            while ( (j - k) >= pri_que.top().second /*pri_que.top().second <= j - k*/ ) {
//                pri_que.pop();
//            }

//            ans.push_back( pri_que.top().first );
//        }
//        return ans;
    }
}
void tst_maxSlidingWindow() {

    std::vector<int> nums { 1, 3, -1, -3, 5, 3, 6, 7 };

    auto res = maxSlidingWindow( nums, /*3*/ nums.size() );
    PrintInContainer(res);

//    std::priority_queue< int > p_q;
//    p_q.emplace(-1);
//    p_q.emplace(123);
//    p_q.emplace(21);
//    p_q.emplace(2048);
//    std::cout << "max=" << p_q.top() << ", sz=" << p_q.size() << std::endl;
}

/*
    219. 存在重复元素 II
    给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，
    使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k。

    示例 1:
    输入: nums = [1,2,3,1], k = 3
    输出: true

    示例 2:
    输入: nums = [1,0,1,1], k = 1
    输出: true

    示例 3:
    输入: nums = [1,2,3,1,2,3], k = 2
    输出: false
*/
bool containsNearbyDuplicate(vector<int>& nums, int k) {
    std::set<int> s;

    for ( int i = 0; i < nums.size(); i ++ ) {

        if ( s.find( nums[ i ] ) != s.end() ) {// find one ele
            return true;
        }

        s.insert( nums[ i ] );

        if ( s.size() > k ) {
            s.erase( i - k );
        }
    }
    return false;
}
void tst_containsNearbyDuplicate() {
    std::vector<int> arr{ 1,0,1,1 };
    std::cout << "containsNearbyDuplicate=" << containsNearbyDuplicate(arr, 1) << std::endl;
}

/*
    20. 有效的括号
    给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。

    有效字符串需满足：
    左括号必须用相同类型的右括号闭合。
    左括号必须以正确的顺序闭合。

    示例 1：
    输入：s = "()"
    输出：true

    示例 2：
    输入：s = "()[]{}"
    输出：true

    示例 3：
    输入：s = "(]"
    输出：false

    示例 4：
    输入：s = "([)]"
    输出：false

    示例 5：
    输入：s = "{[]}"
    输出：true
*/
bool IsValidString(std::string s) {
    {
//        unordered_map<char, char> pairs = {
//            {')', '('},
//            {']', '['},
//            {'}', '{'}
//        };
//        stack<char> stk;
//        for (char ch: s) {
//            if (pairs.count(ch)) {
//                if (stk.empty() || stk.top() != pairs[ch]) {
//                    std::cout << "ret false, ch=" << ch << std::endl;
//                    return false;
//                }
//                stk.pop();
//            }
//            else {
//                stk.push(ch);
//            }
//        }
//        return stk.empty();
    }
    {
        if (s.size() % 2 == 1) return false;

        std::unordered_map < char, char > pairs = {
            {')', '('},
            {']', '['},
            {'}', '{'}
        };
        std::stack < char > stk;

        for ( char ch : s ) {

            if ( pairs.count(ch) ) {

                if ( stk.empty() || stk.top() != pairs[ch] ) {
                    std::cout << "ret false, ch=" << ch << std::endl;
                    return false;
                }
                std::cout << "pop=" << stk.top() << ", ch=" << ch << std::endl;
                stk.pop();
            } else {
                stk.push(ch);
                std::cout << "push=" << ch << std::endl;
            }
        }
        return stk.empty();

//        for ( std::unordered_map < char, char >::iterator it = um.begin(); it != um.end(); it ++ ) {
//            std::cout << " key=" << it->first << ", val=" << it->second;
//        }
//        std::cout << std::endl;
    }
    return true;
}
void tst_IsValidString() {
    std::string str = "()[]{}";
    std::cout << "ret=" << IsValidString(str) << std::endl;
}

/*
    225. 用队列实现栈
    请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通队列的全部四种操作（push、top、pop 和 empty）。

    实现 MyStack 类：
    void push(int x) 将元素 x 压入栈顶。
    int pop() 移除并返回栈顶元素。
    int top() 返回栈顶元素。
    boolean empty() 如果栈是空的，返回 true；否则，返回 false；

    示例：
    输入：
        ["MyStack", "push", "push", "top", "pop", "empty"]
        [[], [1], [2], [], [], []]
    输出：
        [null, null, null, 2, 2, false]

    解释：
        MyStack myStack = new MyStack();
        myStack.push(1);
        myStack.push(2);
        myStack.top(); // 返回 2
        myStack.pop(); // 返回 2
        myStack.empty(); // 返回 False
*/

class MyStack {
public:
    void push( int val ) {
        que1.push(val);
    }
    int top() {
        return que1.front();
    }
    int pop() {
       int sz = que1.size();
       sz --;
       while ( sz -- ) {
           que2.push(que1.front());
           que1.pop();
       }

       int res = que1.front();
       que1.pop();

       que1 = que2;
       while ( !que2.empty() ) {
           que2.pop();
       }
       return res;
    }
    bool empyt() {
        return que1.empty();
    }
private:
    std::queue<int> que1;
    std::queue<int> que2;
};
void tst_MyStack() {
    MyStack ms;
}

/*
    209. 长度最小的子数组
    给定一个含有 n 个正整数的数组和一个正整数 s ，
    找出该数组中满足其和 ≥ s 的长度最小的 连续子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

    示例：
    输入：s = 7, nums = [2,3,1,2,4,3]
    输出：2
    解释：子数组 [4,3] 是该条件下的长度最小的子数组。

-----------------------------------------------------------------------
复杂度分析：
-----------------------------------------------------------------------
*/
int minSubArrayLen(int target, vector<int>& nums) {
    int start = 0, end = 0;
    int ans = INT_MAX;
    int sum = 0;

    int n = nums.size();

    while ( end  <  n ) {

        sum += nums[ end ];

        while ( sum > target ) {
            ans = std::min(ans, end - start + 1);
            sum -= nums[ start ];
            start ++;
        }
        end ++;
    }

    return ans == INT_MAX ? 0 : ans;
}
void tst_minSubArrayLen() {
    int target = 7;
    std::vector<int> nums{2,3,1,2,4,3};

    std::cout << "ret=" << minSubArrayLen(target, nums) << std::endl;
//    std::cout << "max=" << INT_MAX << ", min=" << INT_MIN << std::endl;
}


/*
    187. 重复的DNA序列
    所有 DNA 都由一系列缩写为 'A'，'C'，'G' 和 'T' 的核苷酸组成，例如："ACGAATTCCG"。
    在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。
    编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。

    示例 1：
    输入：s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"
    输出：["AAAAACCCCC","CCCCCAAAAA"]

    示例 2：
    输入：s = "AAAAAAAAAAAAA"
    输出：["AAAAAAAAAA"]

*/
vector<string> findRepeatedDNASequences(string s) {
    vector<string> ans;

    return ans;
}
void tst_findRepeatedDNASequences() {

}


/*
    面试题 16.25. LRU 缓存
    设计和构建一个"最近最少使用"缓存，该缓存会删除最近最少使用的项目。
    缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。

    它应该支持以下操作： 获取数据 get 和 写入数据 put 。

    获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。
    写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。

示例:
    LRUCache cache = new LRUCache( 2 );

    cache.put(1, 1);
    cache.put(2, 2);
    cache.get(1);       // 返回  1
    cache.put(3, 3);    // 该操作会使得密钥 2 作废
    cache.get(2);       // 返回 -1 (未找到)
    cache.put(4, 4);    // 该操作会使得密钥 1 作废
    cache.get(1);       // 返回 -1 (未找到)
    cache.get(3);       // 返回  3
    cache.get(4);       // 返回  4

*/
class LRUCache {
public:
    LRUCache(int capacity) : cap_(capacity) {
    }

    int get(int key) {

        auto it = um_.find(key);
        if ( it == um_.end() ) {// no found key,,,
            return -1024;
        }

        auto target_it = it->second;// found input query: key

        std::pair<int, int> newobj{ key, target_it->second };
        lru_.push_front(newobj);
        lru_.erase(it->second);

        um_.erase(key);
        um_.emplace(key, lru_.begin());

        return newobj.second;
    }

    void put(int key, int value) {

        auto it = um_.find(key);
        if ( it != um_.end() ) {
            lru_.erase(it->second);
            um_.erase(key);
        }

        std::pair<int, int> newEle{key, value};

        lru_.push_front(newEle);
        um_.emplace( key, lru_.begin() );

        if ( lru_.size() > cap_ ) {
            um_.erase( lru_.back().first );
            lru_.pop_back();
        }

    }

private:
    std::list < std::pair<int, int> > lru_;
    std::unordered_map< int, std::list<std::pair<int,int>>::iterator > um_;

    int cap_;
};

/*
    460. LFU 缓存
    请你为 最不经常使用（LFU）缓存算法设计并实现数据结构。

    实现 LFUCache 类：
    LFUCache(int capacity) - 用数据结构的容量 capacity 初始化对象
    int get(int key)       - 如果键存在于缓存中，则获取键的值，否则返回 -1。
    void put(int key, int value) -
    如果键已存在，则变更其值；
    如果键不存在，请插入键值对。
    当缓存达到其容量时，则应该在插入新项之前，使最不经常使用的项无效。
    在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 最久未使用 的键。
    注意「项的使用次数」就是自插入该项以来对其调用 get 和 put 函数的次数之和。使用次数会在对应项被移除后置为 0 。

    为了确定最不常使用的键，可以为缓存中的每个键维护一个 使用计数器 。使用计数最小的键是最久未使用的键。

    当一个键首次插入到缓存中时，它的使用计数器被设置为 1 (由于 put 操作)。
    对缓存中的键执行 get 或 put 操作，使用计数器的值将会递增。

    示例：
    输入：
    ["LFUCache", "put", "put", "get", "put", "get", "get", "put", "get", "get", "get"]
    [[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]
    输出：
    [null, null, null, 1, null, -1, 3, null, -1, 3, 4]

    解释：
    // cnt(x) = 键 x 的使用计数
    // cache=[] 将显示最后一次使用的顺序（最左边的元素是最近的）
    LFUCache lFUCache = new LFUCache(2);
    lFUCache.put(1, 1);   // cache=[1,_], cnt(1)=1
    lFUCache.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1
    lFUCache.get(1);      // 返回 1
                          // cache=[1,2], cnt(2)=1, cnt(1)=2
    lFUCache.put(3, 3);   // 去除键 2 ，因为 cnt(2)=1 ，使用计数最小
                          // cache=[3,1], cnt(3)=1, cnt(1)=2
    lFUCache.get(2);      // 返回 -1（未找到）
    lFUCache.get(3);      // 返回 3
                          // cache=[3,1], cnt(3)=2, cnt(1)=2
    lFUCache.put(4, 4);   // 去除键 1 ，1 和 3 的 cnt 相同，但 1 最久未使用
                          // cache=[4,3], cnt(4)=1, cnt(3)=2
    lFUCache.get(1);      // 返回 -1（未找到）
    lFUCache.get(3);      // 返回 3
                          // cache=[3,4], cnt(4)=1, cnt(3)=3
    lFUCache.get(4);      // 返回 4
                          // cache=[3,4], cnt(4)=2, cnt(3)=3
*/
class LFUCache {
public:
    LFUCache(int capacity) {

    }

    int get(int key) {

    }

    void put(int key, int value) {

    }
};


/*
    9. 回文数
    给你一个整数 x ，如果 x 是一个回文整数，返回 ture ；否则，返回 false 。
    回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。

    示例 1：
    输入：x = 121
    输出：true

    示例 2：
    输入：x = -121
    输出：false
    解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

    示例 3：
    输入：x = 10
    输出：false
    解释：从右向左读, 为 01 。因此它不是一个回文数。

    示例 4：
    输入：x = -101
    输出：false
*/
bool isPalindrome(int x) {

    int a = 0, b = x;
    while ( b > 0 ) {
        a = a * 10  + b % 10;
        b = b / 10;
        std::cout << " " << a << " ";
    }
    std::cout << std::endl;
    std::cout << "a=" << a << std::endl;
    return ((a - x) == 0);
}
void tst_isPalindrome_int() {
    std::cout << "ret=" << isPalindrome( 1234321 ) << std::endl;
    std::cout << "ret=" << isPalindrome( 9981 ) << std::endl;
}

bool isPalindrome(std::string str) {
    if ( str.size() == 0 )
        return false;
    if ( str.size() == 1 )
        return true;

    size_t sz = str.size();
    for (size_t i = 0; i < sz; i++)
    {
        if ( str[ i ] != str[ sz - 1 - i ] ) {
            return false;
        }
    }
    return true;
}
void tst_isPalindrome_str() {
    std::cout << "ret=" << isPalindrome( "1234321" ) << std::endl;
    std::cout << "ret=" << isPalindrome( "9981" ) << std::endl;
    std::cout << "ret=" << isPalindrome( "9999" ) << std::endl;
}

/*
    41. 缺失的第一个正数
    给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。
    进阶：你可以实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案吗？

    示例 1：
    输入：nums = [1,2,0]
    输出：3

    示例 2：
    输入：nums = [3,4,-1,1]
    输出：2

    示例 3：
    输入：nums = [7,8,9,11,12]
    输出：1

-----------------------------------------------------------------------
复杂度分析：
-----------------------------------------------------------------------
*/
int firstMissingPositive(vector<int>& nums) {

    int n = nums.size();
    for (int i = 0; i < n; ++i) {
        while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
            swap(nums[nums[i] - 1], nums[i]);
        }
    }
    for (int i = 0; i < n; ++i) {
        if (nums[i] != i + 1) {
            return i + 1;
        }
    }
    return n + 1;
}
void tst_firstMissingPositive() {
    std::vector<int> arr{ 7,8,9,11,12 };
    firstMissingPositive( arr );
}


#include <bits/stdc++.h>
using namespace std;

void print()
{
    cout << endl;
}

template<class T, class... Args>
void print(T num, Args... rest)
{
    cout << num << " --- ";
    print(rest...);
}

void  tst_someClass() {

    {
        print(1, 2, 3, 4, 5);
        return;
    }

    {
        class A {
        };
//        class B{
//        public:
//          A x;
//        }; // sizeof(B) = 1

        class B {
        public:
            A x;
            inline virtual void fun() {
            }
        }; // sizeof(B) = 16

        std::cout << "B=" << sizeof(B) << std::endl; // sizeee=8
        return;
    }
    {

        class CXX {
        public:
            CXX() {}
            ~CXX() {}
            virtual void f1() {
                std::cout << "CXX::f1 called" << std::endl;
            }
        };
        std::cout << "sizeee=" << sizeof(CXX) << std::endl; // sizeee=8
        return ;

        class CA {
        public:
            CA() {}
            ~CA() {}
            void f1() {
                std::cout << "A::f1 called" << std::endl;
            }
        };
        class CB : public CA {
        public:
            CB() {}
            ~CB() {}
            void f1() {
                std::cout << "B::f1 called" << std::endl;
            }
        };

        CA a;
        CB b;
        CA* p1 = &a;
        p1->f1();
        p1 = &b;
        p1->f1();

    }
}

class CBinarySearch {

public:
    int binarySearch_1(std::vector<int>& arr, int target) {

        int low = 0;
        int high = arr.size() - 1;

        while ( low <= high ) {
            int mid = low + ((high - low) >> 1);
            if ( arr [ mid ] == target )
                return mid;
            else if ( arr [ mid ] < target ) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return -1;
    }

    // 查找第一个等于给定值的元素所在的 index
    int bsearchFirstEqual(std::vector<int>& arr, int target) {

        int low = 0;
        int high = arr.size() - 1;

        while ( low <= high ) {

            int mid = low + ((high - low) >> 1);

            if ( arr [ mid ] < target ) {
                low = mid + 1;
            } else if ( arr[ mid ] > target ) {
                high = mid - 1;
            } else { // == target

                if ( mid == 0 || arr[ mid - 1 ] != target ) {
                    return mid;
                } else {
                    high = mid - 1;
                }
            }

        } // end --- for

        return -1;
    }

    // 查找最后一个等于给定值的元素所在的 index
    int bsearchLastEqual(std::vector<int>& arr, int target) {

        int low = 0;
        int high = arr.size() - 1;

        while ( low <= high ) {

            int mid = low + ((high - low) >> 1);

            if ( arr [ mid ] < target ) {
                low = mid + 1;
            } else if ( arr[ mid ] > target ) {
                high = mid - 1;
            } else { // == target

                if ( mid == (arr.size() - 1) || arr[ mid + 1 ] != target ) {
                    return mid;
                } else {
                    low = mid + 1;
                }
            }

        } // end --- for

        return -1;
    }

    // 查找第一个大于等于给定值的元素所在的 index
    int bsearchFirstMore(std::vector<int>& arr, int target) {

        int low = 0;
        int high = arr.size() - 1;

        while ( low <= high ) {

            int mid = low + ((high - low) >> 1);

            if ( arr [ mid ] < target ) {
                low = mid + 1;
            } else if ( arr[ mid ] > target ) {
                high = mid - 1;
            } else { // == target

                if ( mid == 0 || arr[ mid - 1 ] < target ) {
                    return mid;
                } else {
                    low = mid + 1;
                }
            }

        } // end --- for

        return -1;
    }

    // 查找最后一个小于等于给定值的元素所在的 index
    int bsearchLastLess(std::vector<int>& arr, int target) {

        int low = 0;
        int high = arr.size() - 1;

        while ( low <= high ) {

            int mid = low + ((high - low) >> 1);

            if ( arr [ mid ] < target ) {
                low = mid + 1;
            } else if ( arr[ mid ] > target ) {
                high = mid - 1;
            } else { // == target

                if ( mid == arr.size() - 1 || arr[ mid + 1 ] > target ) {
                    return mid;
                } else {
                    low = mid + 1;
                }
            }

        } // end --- for

        return -1;
    }


};
void tst_binarySearch() {

    std::vector<int> arr{ -1, 2, 3, 7, 13, 19, 6655, 65535, 65535, 99871};

    CBinarySearch cbs;
//    std::cout << "findPos=" << cbs.binarySearch_1(arr, 65535) << std::endl;
//    std::cout << "findPos=" << cbs.bsearchFirstEqual(arr, 65535) << std::endl;
    std::cout << "findPos=" << cbs.bsearchLastEqual(arr, 65535) << std::endl;
}



template < class T >
class CShared_Ptr {
private:
    T*   ptr_;
    int* use_count_;

public:


};



/*
    162. 寻找峰值
    峰值元素是指其值大于左右相邻值的元素。
    给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。
    你可以假设 nums[-1] = nums[n] = -∞ 。

    示例 1：
    输入：nums = [1,2,3,1]
    输出：2
    解释：3 是峰值元素，你的函数应该返回其索引 2。

    示例 2：
    输入：nums = [1,2,1,3,5,6,4]
    输出：1 或 5
    解释：你的函数可以返回索引 1，其峰值元素为 2；
         或者返回索引 5， 其峰值元素为 6。

-----------------------------------------------------------------------
复杂度分析：
-----------------------------------------------------------------------
首先要注意题目条件，在题目描述中出现了 nums[-1] = nums[n] = -∞，这就代表着 只要数组中存在一个元素比相邻元素大，那么沿着它一定可以找到一个峰值
根据上述结论，我们就可以使用二分查找找到峰值
查找时，左指针 l，右指针 r，以其保持左右顺序为循环条件
根据左右指针计算中间位置 m，并比较 m 与 m+1 的值，如果 m 较大，则左侧存在峰值，r = m，如果 m + 1 较大，则右侧存在峰值，l = m + 1
时间复杂度：O(logN)
*/
int findPeakElement(vector<int>& nums) {
    int left = 0;
    int right = nums.size() -1;
    while ( left < right ) {
        int mid = left + ((right - left)>>1);
        if ( nums[ mid ] > nums [ mid + 1] ) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
void tst_findPeakElement() {
    std::vector<int> nums{ 1,2,1,3,5,6,4 };
    std::cout << "peak ele=" << findPeakElement(nums) << std::endl;
}


/*
    69. x 的平方根
    实现 int sqrt(int x) 函数。
    计算并返回 x 的平方根，其中 x 是非负整数。
    由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

    示例 1:
    输入: 4
    输出: 2

    示例 2:
    输入: 8
    输出: 2
    说明: 8 的平方根是 2.82842...,
         由于返回类型是整数，小数部分将被舍去。
-----------------------------------------------------------------------
复杂度分析：
-----------------------------------------------------------------------

*/
int mySqrt(int x) {

    int left = 0;
    int right= x;
    int mid = 0;

    while (left <= right) {

        mid = left + ((right - left) >> 1);

        if ( ((long long) (mid * mid)) <= x ) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }

    }
    return mid;
    return 1;
}

/*
    剑指 Offer 16. 数值的整数次方
    实现函数，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。

    示例 1:
    输入: 2.00000, 10
    输出: 1024.00000

    示例 2:
    输入: 2.10000, 3
    输出: 9.26100

    示例 3:
    输入: 2.00000, -2
    输出: 0.25000
    解释: 2-2 = 1/22 = 1/4 = 0.25
*/
double Power(double base, int exponent) {

//    long num = 31;
//    std::cout << "sizeof-long=" << sizeof(num) << std::endl;

//    int n1 = 9;
//    std::cout << "val=" << (n1>>1) << std::endl;

    double ans = 1.0;
    int num = exponent;

    while ( num ) {
        if ( num & 1 )  ans *= base;

        base *= base;
        num = num >> 1;
    }

    return ans;
}
void tst_Power() {
//    std::cout << "function Power=" << Power( 3.001, 3 ) << std::endl;

    //创建一个空的unordered_set容器
    std::unordered_set<std::string> uset;
    //给 uset 容器添加数据
    uset.emplace("http://c.biancheng.net/java/");
    uset.emplace("http://c.biancheng.net/c/");
    uset.emplace("http://c.biancheng.net/python/");
    //查看当前 uset 容器存储元素的个数
    cout << "uset size = " << uset.size() << endl;
    //遍历输出 uset 容器存储的所有元素
    for (auto iter = uset.begin(); iter != uset.end(); ++iter) {
        cout << *iter << endl;
    }

}



/*
    202. 快乐数
    编写一个算法来判断一个数 n 是不是快乐数。

    「快乐数」定义为：
    对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
    然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。
    如果 可以变为 1，那么这个数就是快乐数。
    如果 n 是快乐数就返回 true；不是，则返回 false 。

    示例 1:
    输入: 19
    输出: true
    解释:
    12 + 92 = 82
    82 + 22 = 68
    62 + 82 = 100
    12 + 02 + 02 = 1

    示例 2:
    输入: n = 2
    输出: false

*/
class HappyNum {

public:
    int GetSum(int n) {

        int sum = 0;
        while ( n ) {
            sum += (n % 10) * (n % 10);
            n = n / 10;
        }
        return sum;
    }
    bool isHappy(int n) {
        std::unordered_set<int> us;

        while ( 1 ) {

            int sum = GetSum(n);
            if (sum == 1) {
                return true;
            }
            if ( us.find( sum ) != us.end() ) {// 如果这个sum曾经出现过，说明已经陷入了无限循环了，立刻return false
                return false;
            } else {
                us.insert( sum );
            }
            n = sum;
        }
        return false;
    }

};

void tst_isHappy() {

//    typedef struct psd_header_st_tag
//    {
//        unsigned long saddr; //源地址
//        unsigned long daddr; //目的地址
//        char mbz;//置空
//        char ptcl; //协议类型
//        unsigned short tcpl; //TCP长度, total length - IP length
//    }psd_header_st;

//    psd_header_st ph;
//    std::cout << "sizeof(psd_header)=" << sizeof(psd_header_st) << std::endl;
//    std::cout << "sizeof(ph)=" << sizeof(psd_header_st) << std::endl;
//    std::cout << "sizeof(ph.saddr)=" << sizeof(ph.saddr) << std::endl;
//    return ;

    HappyNum hn;
    std::cout << "result 19=" << hn.isHappy( 19 ) << std::endl;
    std::cout << "result 11=" << hn.isHappy( 11 ) << std::endl;
}

/*
    剑指 Offer 21. 调整数组顺序使奇数位于偶数前面
    输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，
所有偶数位于数组的后半部分。
    示例：
    输入：nums = [1,2,3,4]
    输出：[1,3,2,4] 注：[3,1,2,4] 也是正确的答案之一。
*/
vector<int> exchange(vector<int>& nums) {

    size_t left = 0, right = nums.size() - 1;

    while ( left < right ) {

        if ( (nums[ left ] & 1) == 1 ) {// jishu
            left ++;
            continue;
        }

        if ( (nums[ right ] & 1) == 0 ) { // oushu
            right --;
            continue;
        }
        std::swap( nums[ left++ ], nums[ right-- ] );
    }
    return nums;
}
void tst_exchange() {
    std::vector<int> arr{ 1, 3, 2, 4, 5, 7, 8, 12, 14 };

    auto res = exchange( arr );
    PrintInContainer(res);
}

class CAX {
public:
    CAX() : ptr_( new int( 123 ) ) {
    }
    ~CAX() {
        std::cout << " dst obj, ptr=" << ptr_ << std::endl;
        delete ptr_;
    }
private:
    int* ptr_;
};
CAX getobj(bool flag) {
    CAX a;
    CAX b;
    if (flag)
    {
        return a;
    }
    else {
        return b;
    }
    return b;
}
void tst_del_class_ptr() {
    std::cout << "beg ------------" << std::endl;
    CAX tmp = getobj(false);
    std::cout << "end ------------" << std::endl;
}

void tst_mystring() {
    class MyString {
        void copy_data( const char* data ) {
            m_data = new char[ m_len + 1 ];
            memcpy(m_data, data, m_len);
            m_data[ m_len ] = '\0';
        }
    public:
        MyString() : m_data( nullptr ), m_len( 0 ) {
        }
        virtual ~MyString() {
            if (m_data) {
                cout <<"delet "<<(void*)m_data << std::endl;
                delete []m_data;
                m_len = 0;
            }
        }
        MyString(const char* data) {
            if ( strlen( data ) ) {
                m_len = strlen(data);
                copy_data(data);
            }
        }
        MyString(const MyString& other) {
            m_len = strlen( other.m_data );
            copy_data( other.m_data );
            std::cout << "Copy Constructor is called! source:" << other.m_data << std::endl;
        }
        MyString& operator = (const MyString& other) {
            if  ( this != &other ) {
                if ( m_data ) {
                    delete []m_data;
                    m_len = 0;
                }
                m_len = strlen( other.m_data );
                copy_data( other.m_data );
            }
            cout << "Copy Assignment is called! source:"<< other.m_data << std::endl;
            return *this;
        }


        MyString(MyString&& other) {
            std::cout << "Move Constructor is called! source:" << other.m_data << std::endl;
            m_len = other.m_len;
            m_data = other.m_data;
            other.m_len = 0;
            other.m_data = nullptr;
        }
//        MyString& operator = (MyString&& other) {
//            std::cout << "Move Assignment is called! source:"<< other.m_data << std::endl;
//            if  ( this != &other ) {
//                m_len = other.m_len;
//                m_data = other.m_data;
//                other.m_len = 0;
//                other.m_data = nullptr;
//            }
//            return *this;
//        }
    private:
        char* m_data;
        size_t m_len;
    };


    MyString a;
    a = MyString("Hello");
    std::vector<MyString> vec;
//    vec.push_back(MyString("World"));
    vec.emplace_back(MyString("World"));

    /*
Move Assignment is called! source:Hello
Move Constructor is called! source:World
delet 0x2460ac0
delet 0x2460aa0
    */
}

int bitCount(unsigned int n) {

    unsigned int c = 0;
    for ( c = 0; n; c ++ ) {
        n &= (n - 1);
    }
    return c;
}
void tst_bitCount() {
    std::cout << "bit count = " << bitCount( 15 ) << std::endl;
}


void PreOrderRec(BstNode* root) {
    if (!root) return;
    {
        std::cout << " " << root->val ;
        if (root->left)
            PreOrderRec(root->left);
        if (root->right)
            PreOrderRec(root->right);
    }
}
/*
    复杂度分析

    时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。
    空间复杂度：O(n)，为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。
*/
std::vector<int> PreOrderNonRecImpl(BstNode* root) {
    std::vector<int> res;
    if (!root) return res;

    std::stack<BstNode*> stk;
    BstNode* node = root;
    while ( !stk.empty() || node ) {

        while ( node ) {
            res.emplace_back(node->val);
            stk.emplace(node);
            node = node->left;
        }
        node = stk.top();
        stk.pop();
        node = node->right;
    }
    return res;
}
void PreOrderNonRec(BstNode* root) {
    if( !root ) return;
    auto res = PreOrderNonRecImpl( root );
    PrintInContainer(res);
}

void inOrderRecru(BstNode* root) {
    if (!root) return;
    if (root->left)
        inOrderRecru(root->left);
    std::cout << " " << root->val;
    if (root->right)
        inOrderRecru(root->right);
}
std::vector<int> inOrderNonRecruImpl(BstNode* root) {
    std::vector<int> res;
    if (!root) return res;
    {
        std::stack< BstNode* > stk;
        while ( root || !stk.empty() ) {

            while ( root ) {
                stk.push( root );
                root = root->left;
            }
            root = stk.top();
            stk.pop();

            res.push_back(root->val);
            root = root->right;
        }
    }
    return res;
}
void inOrderNonRecru(BstNode* root) {
    auto res = inOrderNonRecruImpl(root);
    PrintInContainer(res);
}


void CreateBstTree(const std::vector<int>& inVec) {// 构建二叉树；
    for ( auto val : inVec ) {
        BstNode* node = new BstNode(val);
        AddNewNode(g_pBstTree, node);
    }
}


void AddNewNode(BstNode*& root, BstNode* newNode) {
    {
        BstNode* parent = nullptr;
        BstNode* tmp = root;

        while ( tmp ) {
            parent = tmp;
            if ( newNode->val > tmp->val ) {
                tmp = tmp->right;
            } else {
                tmp = tmp->left;
            }
        }
        newNode->parent_ = parent;
        if (!parent) {
            root = newNode;
        } else if (newNode->val > parent->val) {
            parent->right = newNode;
        } else {
            parent->left = newNode;
        }
    } // end bracket

}

void CreateBstTree() {// 构建二叉树；
//    std::cout << "-------------------------------" << std::endl;
//    std::cout << std::boolalpha;
//    std::cout << "Minimum value for int: " << std::numeric_limits<int>::min() << std::endl;
//    std::cout << "Maximum value for int: " << std::numeric_limits<int>::max() << std::endl;

    {
        ::srand(time(nullptr));

//        std::cout << "-------------------------------beg random val-------------------------------" << std::endl;
        for ( int i = 0; i < 10; i++ ) {
            int randVal = rand() % 200;

            BstNode* newNode = new BstNode(randVal);
            AddNewNode(g_pBstTree, newNode);
        }
        return;
    }

    {
        ::srand(time(nullptr));

        int count = 20;
//        std::cout << "-------------------------------beg random val-------------------------------" << std::endl;
        for (int i = 0; i < count; ++i) {
            int randVal = rand() % (300);
            std::cout << randVal << "  ";

            BstNode* pNewNode = new BstNode(randVal);
            AddNewNode(g_pBstTree, pNewNode);
        }
        std::cout << std::endl;
//        std::cout << "-------------------------------end random val-------------------------------" << std::endl;
        return;
    }
}
bool insertNewBstNode(BstNode*& root, int val) {
    {
        if (!root) {
            root = new BstNode(val);
            return true;
        }
        if ( val < root->val ) {
            return insertNewBstNode(root->left, val);
        }
        return insertNewBstNode(root->right, val);
    }
}
void CreateBstTreeEx() {
    ::srand(time(nullptr));

    for ( int i = 0; i < 10; i++ ) {
        insertNewBstNode(g_pBstTree, rand() % 200);
    }
}


/*
    从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。
    例如: 给定二叉树: [3,9,20,null,null,15,7],
        3
       / \
      9  20
        /  \
       15   7
    返回其层次遍历结果：
    [
      [3],
      [9,20],
      [15,7]
    ]
*/
vector<vector<int>> levelOrder_1(BstNode* root) {

    {
        std::vector<std::vector<int>> res;

        std::queue<BstNode*> que;
        que.push(root);

        while (!que.empty()) {

            std::vector<int> level;
            size_t sz = que.size();
            for ( size_t i = 0; i < sz; i ++ ) {

                auto node = que.front(); que.pop();
                level.push_back(node->val);

                if ( node->left ) que.push(node->left);
                if ( node->right )que.push(node->right);
            }

            res.push_back( level );
        }
        return res;
    }

}

int bstNodeCount(BstNode* root) {
    if (!root) return 0;
    return 1 + bstNodeCount(root->left) + bstNodeCount(root->right);
}
void tst_bst_operator() {

    {

        const int size_cnt = 16;
        std::vector<int> nums{ 91, 33, 77, 21, 8, 23, 4, 34 };
        std::cout << "first print --- ---" << std::endl;
        for ( size_t i = 0; i < nums.size(); i ++ ) {
            std::cout << " " << nums[ i ] % size_cnt;
        }
        std::cout << std::endl;

        std::cout << "second print --- ---" << std::endl;
        for ( size_t i = 0; i < nums.size(); i ++ ) {
            std::cout << " " << (nums[ i ] & (size_cnt - 1));
        }
        std::cout << std::endl;
//        return ;
    }
    CreateBstTree();
    {
        std::cout << std::endl;
        std::cout << "-------------------------------inOrder beg-------------------------------" << std::endl;
        inOrderRecru(g_pBstTree);
        std::cout << std::endl;
        std::cout << "-------------------------------inOrder end-------------------------------" << std::endl;
        std::cout << std::endl;
    }
{
        std::cout << std::endl;
        std::cout << "-------------------------------inOrderNonRecru beg-------------------------------" << std::endl;
        inOrderNonRecru(g_pBstTree);
        std::cout << std::endl;
        std::cout << "-------------------------------inOrderNonRecru end-------------------------------" << std::endl;
        std::cout << std::endl;
}
    {
        std::cout << std::endl;
        std::cout << "-------------------------------preOrderNonRecr beg-------------------------------" << std::endl;
        PreOrderNonRec(g_pBstTree);
        std::cout << std::endl;
        std::cout << "-------------------------------preOrderNonRecr end-------------------------------" << std::endl;
        std::cout << std::endl;
    }
    {
        std::cout << std::endl;
        std::cout << "-------------------------------preOrderRecr beg-------------------------------" << std::endl;
        PreOrderRec(g_pBstTree);
        std::cout << std::endl;
        std::cout << "-------------------------------preOrderRecr end-------------------------------" << std::endl;
        std::cout << std::endl;
    }

    std::cout << "before level print ---" << std::endl;
    auto ret = levelOrder_1(g_pBstTree);
    for ( auto itLevel : ret ) {
        for ( auto itVal : itLevel ) {
            std::cout << " " << itVal;
        }
        std::cout << std::endl;
    }
    std::cout << "end    level print ---" << std::endl << std::endl;

    std::cout << " bst count=" << bstNodeCount(g_pBstTree) << std::endl;
}




/*
    剑指 Offer 32 - III. 从上到下打印二叉树 III
    请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。

    例如:
    给定二叉树: [3,9,20,null,null,15,7],
            3
           / \
          9  20
            /  \
           15   7
    返回其层次遍历结果：

    [
        [3],
        [20,9],
        [15,7]
    ]
*/
vector<vector<int>> zhiPrint_levelOrder(BstNode* root) {


            vector<vector<int>> allNode;
            if (root == nullptr) {
                return allNode;
            }
         
            std::queue< BstNode* >  que;
            que.push( root );

            int flag  = 1;
            while (  !que.empty()   ) {

                std::vector<int> level;
                size_t sz = que.size();
                for ( size_t i = 0; i < sz; i ++ ) {

                    auto node = que.front(); que.pop();
                    level.push_back( node->val );

                    if ( node->left ) que.push( node->left );
                    if ( node->right )que.push( node->right );
                }
                
                if  (     flag % 2 == 0      ) { // 偶数
                    std::reverse( level.begin(), level.end() );
                }
                allNode.push_back( level );
                flag ++;
            }
            return allNode;

}

void tst_bst_level_order() {

    CreateBstTree();
    {
        std::cout << std::endl;
        std::cout << "-------------------------------inOrder beg-------------------------------" << std::endl;
        inOrderRecru(g_pBstTree);
        std::cout << std::endl;
        std::cout << "-------------------------------inOrder end-------------------------------" << std::endl;
        std::cout << std::endl;
    }

    {
        std::cout << "before level print ---" << std::endl;
        auto ret = levelOrder_1(g_pBstTree);
        for ( auto itLevel : ret ) {
            for ( auto itVal : itLevel ) {
                std::cout << " " << itVal;
            }
            std::cout << std::endl;
        }
        std::cout << "end    level print ---" << std::endl << std::endl;
    }

    {
        std::cout << "before zhi level print ---" << std::endl;
        auto ret = zhiPrint_levelOrder(g_pBstTree);
        for ( auto itLevel : ret ) {
            for ( auto itVal : itLevel ) {
                std::cout << " " << itVal;
            }
            std::cout << std::endl;
        }
        std::cout << "end    zhi level print ---" << std::endl << std::endl;
    }

}

/*
    二叉树第k层的结点个数
*/
int GetKLevelNodesCount(BstNode* root, int k) {
    if ( !root ) return 0;
    if ( 1 == k ) return 1;
    return GetKLevelNodesCount(root->left, k - 1) + GetKLevelNodesCount(root->right, k - 1);
}
// 树的深度
int GetDepthByBstTree(BstNode* root) {
    if ( !root ) return 0;
    int leftDepth = GetDepthByBstTree(root->left);
    int rightDepth = GetDepthByBstTree(root->right);
    return std::max(leftDepth, rightDepth) + 1;
}

// 判断两棵二叉树是否结构相同
bool isSameBstTree( BstNode* t1, BstNode* t2) {
    if ( t1 == nullptr && t2 == nullptr ) {
        return true;
    }
    if ( t1 != nullptr || t2 != nullptr ) {
        return false;
    }
    if ( t1->val != t2->val ) {
        return false;
    }

    return isSameBstTree(t1->left, t2->left) && isSameBstTree(t1->right, t2->right);
}

/*
    34. 在排序数组中查找元素的第一个和最后一个位置
    给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

    如果数组中不存在目标值 target，返回 [-1, -1]。

    进阶：你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？

    示例 1：
    输入：nums = [5,7,7,8,8,10], target = 8
    输出：[3,4]

    示例 2：
    输入：nums = [5,7,7,8,8,10], target = 6
    输出：[-1,-1]

    示例 3：
    输入：nums = [], target = 0
    输出：[-1,-1]

实现了C++的lower_bound和upper_bound，模板题，记住这2个函数的实现会很有用。
需要注意的是，当lower_bound和upper_bound的返回值一样的时候，说明这个元素不存在。
而且这两个函数的实现极其相似，只有一个条件不同，
在lower_bound中，是e<=nums[mi]，
而在upper_bound中，对应的是e<nums[mi]，就只有这一点不同，所以也很好记。

注意:
lower_bound是找到有序数组中，第一个满足nums[i]>=e的i
upper_bound是找到有序数组中，第一个满足nums[i]>e的i。其中e是待查找的元素。
*/
class CSearchValRange {
public:
    int n;
    int lower_Bound(vector<int> &nums, int target) {
        size_t left = 0;
        size_t right = nums.size();
        while ( left < right ) {
            size_t mid = left + ((right - left) >> 1);

            if ( nums[ mid ] >= target ) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
    int upper_Bound(vector<int> &nums, int target) {
        size_t left = 0;
        size_t right = nums.size();

        while ( left < right ) {
            size_t mid = left + ((right - left) >> 1);

            if ( nums[ mid ] > target ) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
    vector<int> searchRange(vector<int> &nums, int target) {
        vector<int> res;
        if (nums.empty()) return std::vector<int>{ -1, -1 };

        int lo = lower_Bound(nums, target);
        int hi = upper_Bound(nums, target);
        if (lo == hi) return std::vector<int>{ -1, -1 };

        return std::vector<int>{ lo, hi - 1 };
    }
};

/*
    287. 寻找重复数
    给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。
    假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。

    示例 1：
    输入：nums = [1,3,4,2,2]
    输出：2

    示例 2：
    输入：nums = [3,1,3,4,2]
    输出：3

    示例 3：
    输入：nums = [1,1]
    输出：1

    示例 4：
    输入：nums = [1,1,2]
    输出：1

*/
int findDuplicate(vector<int>& nums) {
    size_t left = 0;
    size_t right = nums.size() - 1;

    while ( left < right ) {
        size_t mid = left + ((right - left) >> 1);

        size_t cnt = 0;
        for ( auto num : nums ) {
            if ( num <= mid )
                cnt ++;
        }// end --- for

        if ( cnt > mid ) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }
    return left;
}
void tst_findDuplicate() {
    std::vector<int> arr{1, 2, 2, 3, 4, 5, 6, 7};
//    std::vector<int> arr{1,3,4,2,2};
//    std::vector<int> arr{3,1,3,4,2};
    std::cout << "find result=" << findDuplicate(arr) << std::endl << std::endl << std::endl;
}


/*
    1. 两数之和
    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。
    你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。
    你可以按任意顺序返回答案。

    示例 1：
    输入：nums = [2,7,11,15], target = 9
    输出：[0,1]
    解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

    示例 2：
    输入：nums = [3,2,4], target = 6
    输出：[1,2]

    示例 3：
    输入：nums = [3,3], target = 6
    输出：[0,1]
*/
std::vector<int> twoSum_nosort(std::vector<int>& nums, int target) {

    std::unordered_map<int, int> hashTable;

    for ( int i = 0; i < nums.size(); i ++ ) {

        auto it = hashTable.find( target - nums[ i ] );

        if ( it != hashTable.end() ) { // no found val,,,
            return std::vector<int>{ i, it->second };
        } else {
            hashTable[ nums[ i ] ] = i;
        }
    }
    return std::vector<int>{ -1, -1 };
}
void tst_twoSum_nosort() {

    {
//        std::vector<int> v1{ 2, 7, 11, 15 };
        std::vector<int> v1{ 2, 11, 15, 7, 8};
        auto ves = twoSum_nosort(v1, 9);
        PrintInContainer(ves);
        std::cout << std::endl;
    }
    {
        std::vector<int> v1{ 10,26,30,31,47,60 };
        auto ves = twoSum_nosort(v1, 40);
        PrintInContainer(ves);
        std::cout << std::endl;
    }

}



/*
    7. 整数反转
    给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

    示例 1:
    输入: 123
    输出: 321

    示例 2:
    输入: -123
    输出: -321

    示例 3:
    输入: 120
    输出: 21
    注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31, 2^31 − 1]。
    请根据这个假设，如果反转后整数溢出那么就返回 0。
*/
int reverseInt(int x) {
    int res = 0;
    auto pfnCheck = [&]() -> bool {
        if ( res > INT_MAX || res < INT_MIN )
            return true;
        else
            return false;
    };

    do {
        if ( pfnCheck() ) return 0;
        res = res * 10;

        if ( pfnCheck() ) return 0;
        res += (x % 10);
        std::cout << "res=" << res << ", (x % 10)=" << (x % 10) << std::endl;
    } while (x /= 10);
    return res;
}
void tst_reverseInt() {
//    std::cout << "ret=" << reverseInt(-1998) << std::endl;
    std::cout << "input=" << 1534236469 << ", ret=" << reverseInt(1534236469) << std::endl;
//    std::cout << "input=" << 1234567 << ", ret=" << reverseInt(1234567) << std::endl;
//    std::cout << "ret=" << reverseInt(INT_MAX) << std::endl;
}


void tst_hashTable() {
    unordered_map<string,string> mymap =
    {
        {"house","maison"},
        {"apple","pomme"},
        {"tree","arbre"},
        {"book","livre"},
        {"door","porte"},
        {"grapefruit","pamplemousse"}
    };
    /************begin和end迭代器***************/
    cout << "mymap contains:";
    for ( auto it = mymap.begin(); it != mymap.end(); ++it )
        cout << " " << it->first << ":" << it->second;
    cout << endl;
    /************bucket操作***************/

    size_t n = mymap.bucket_count();
    cout << "mymap has " << n << " buckets.\n";

    for (size_t i=0; i<n; ++i)
    {
        cout << "bucket #" << i << "'s size:"<<mymap.bucket_size(i)<<" contains: ";
        for (auto it = mymap.begin(i); it!=mymap.end(i); ++it)
            cout << "[" << it->first << ":" << it->second << "] ";
        cout << "\n";
    }

    cout <<"\nkey:'apple' is in bucket #" << mymap.bucket("apple") <<endl;
    cout <<"\nkey:'computer' is in bucket #" << mymap.bucket("computer") <<endl;
}

//void iniq(q, data)
//{
//    Node* node =new Node;
//    node->val= data;
//    node->next= nullptr;
//    q.head = q.tail = node;
//}

void tst_unorder_set() {

    std::unordered_set < int > us;

    us.insert( 372 );
    us.insert( 372 );
    us.insert( 123 );
    us.insert( 456 );
    us.insert( 991 );

    PrintInContainer( us );
}


/*
    415. 字符串相加
    给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。

    提示：
    num1 和num2 的长度都小于 5100
    num1 和num2 都只包含数字 0-9
    num1 和num2 都不包含任何前导零
    你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式

复杂度分析

时间复杂度：O(len1, len2)。竖式加法的次数取决于较大数的位数。
空间复杂度：O(1)。除答案外我们只需要常数空间存放若干变量。
*/
std::string addStrings(std::string num1, std::string num2) {

    {
        string str;
        int cur = 0, i = num1.size()-1, j = num2.size()-1;
        while (i >= 0 || j >= 0 || cur != 0) {
            if (i >= 0) cur += num1[i--] - '0';
            if (j >= 0) cur += num2[j--] - '0';
            str += to_string (cur % 10);
            cur /= 10;
        }
        reverse(str.begin(), str.end());
        return str;
    }

    {
        std::string ans;

        int i = num1.size() - 1;
        int j = num2.size() - 1;
        int add = 0;

        while ( i >= 0 || j >= 0 ) {

            int v1 = (i >= 0) ? num1[ i ] - '0' : 0;
            int v2 = (j >= 0) ? num2[ j ] - '0' : 0;

            auto result = v1 + v2 + add;
            ans.push_back( '0' + result % 10 );
            add = result / 10;

            i -= 1;
            j -= 1;
        }

        return ans;
    }
}
void tst_addStrings() {
    std::cout << "add res=" << addStrings( "334", "666" ) << std::endl;
//    std::cout << "add res=" << addStrings( "333", "666" ) << std::endl;
//    std::cout << "add res=" << addStrings( "333", "766" ) << std::endl;
}

/*
    347. 前 K 个高频元素
    给定一个非空的整数数组，返回其中出现频率前 K 高的元素。

    示例 1:
    输入: nums = [1,1,1,2,2,3], k = 2
    输出: [1,2]

    示例 2:
    输入: nums = [1], k = 1
    输出: [1]

    提示：
    你可以假设给定的 k 总是合理的，且 1 ≤ k ≤ 数组中不相同的元素的个数。
    你的算法的时间复杂度必须优于 O(n log n) , n 是数组的大小。
    题目数据保证答案唯一，换句话说，数组中前 k 个高频元素的集合是唯一的。
    你可以按任意顺序返回答案。
*/
vector<int> topKFrequent(vector<int>& nums, int k) {
    vector<int> res;

    std::unordered_map<int, int> um;
    for ( auto ele : nums ) {
        um [ ele ]++;
    }

    struct mycompare {
        bool operator ()( const pair<int,int>& p1, const pair<int,int>& p2 ) {
            return p1.second > p2.second;
        }
    };

    std::priority_queue< pair<int,int>, vector<pair<int,int>>, mycompare > pq;

    for ( auto it : um ) {
        std::cout << " " << it.first << ", " << it.second << std::endl;
        pq.push( it );
        if ( pq.size() > k ) {
            pq.pop();
        }
    }

    while ( pq.size() ) {
        res.push_back( pq.top().first );
        pq.pop();
    }

    std::cout << std::endl;
    return res;
}
void tst_topKFrequent() {
    std::vector<int> nums{ 1, 2, 3, 1, 3, 3, 9, 10};
    auto res = topKFrequent(nums, 2);
    PrintInContainer(res);
}

void ReverseAndCount(int n) {
    if ( n <= 0 ) {
        return;
    }

    int bk1 = n;
    int count = 0;

    int  ans = 0;
    while ( bk1 ) {

        ans = ans * 10 + bk1 % 10;

        bk1 = bk1 / 10;
        count ++;

//        std::cout << "ans=" << ans << std::endl;
    }

    std::cout << "bit count=" << count << std::endl;
    std::cout << "ans=" << ans << std::endl;
}
void tst_reverseAndCount() {
    ReverseAndCount( 123456789 );
}


/*
    LeetCode-2 两数相加/链表求和
    给出两个 非空 的链表用来表示两个非负的整数。
    其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。

    如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。

    您可以假设除了数字 0 之外，这两个数都不会以 0 开头。

    示例：
    输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)
    输出：7 -> 0 -> 8
    原因：342 + 465 = 807
*/
class Solution_addTwoNumbers {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        {
            ListNode* dummy = new ListNode( -1 );
            auto pre = dummy;
            int plus = 0;

            while ( l1 || l2 || plus ) {
                int sum = 0;
                if ( l1 ) {
                    sum += l1->val; l1 = l1->next;
                }
                if ( l2 ) {
                    sum += l2->val; l2 = l2->next;
                }
                sum += plus;

                pre->next = new ListNode( sum % 10 );
                pre = pre->next;
                plus = plus / 10;
            }
            return dummy->next;
        }
        {
            ListNode* dummy = new ListNode(-1);
            auto pre = dummy;
            int plus = 0;

            while ( l1 || l2 || plus ) {
                int sum = 0;
                if ( l1 ) {
                    sum += l1->val; l1 = l1->next;
                }
                if ( l2 ) {
                    sum += l2->val; l2 = l2->next;
                }
                sum += plus;

                pre->next = new ListNode( sum % 10 );
                pre = pre->next;

                plus = sum / 10;
            }
            return dummy->next;
        }
    }
    void Test_addTwoNumber() {
        std::vector<int> v1{9, 1, 3};
        std::vector<int> v2{8, 2, 9};

        auto l1 = ConstructList(v1);
        auto l2 = ConstructList(v2);
        auto ret = addTwoNumbers(l1, l2);
        PrintList(ret);
    }
};
void tst_addTwoNumber() {
    Solution_addTwoNumbers sa;
    sa.Test_addTwoNumber();
}


/*
验证二叉搜索树
给定一个二叉树，判断其是否是一个有效的二叉搜索树。

假设一个二叉搜索树具有如下特征：
节点的左子树只包含小于当前节点的数。
节点的右子树只包含大于当前节点的数。
所有左子树和右子树自身必须也是二叉搜索树。

示例 1:
输入:
    2
   / \
  1   3
输出: true

示例 2:
输入:
    5
   / \
  1   4
     / \
    3   6
输出: false
解释: 输入为: [5,1,4,null,null,3,6]。
     根节点的值为 5，但是其右子节点值为 4。
*/
bool isValidBst(BstNode* root, long long pre) {
    if (!root) return true;
    
    if (!isValidBst(root->left, pre)) return false;
    if (root->val <= pre) return false;

    pre = root->val;
    return isValidBst(root->right, pre);
}
void tst_isValidBst() {
    // CreateBstTree();

    // std::vector<BstNode *> retVec;
    // extractNodeInorder(g_pBstTree, retVec);
    // retVec[retVec.size() - 1 ]->val = 2;

    printInorder(g_pBstTree);
    std::cout << std::endl;
    
    long long pre = LONG_MIN;
    // pre = 0;
    std::cout << "pre=" << pre << std::endl;

    std::cout << "valid res=" << isValidBst(g_pBstTree, pre) << std::endl;
    std::cout << std::endl;

    std::cout << "isBalanced=" << isBalanced(g_pBstTree) << std::endl;
    std::cout << std::endl;
}



/*
    二叉树的镜像
    请完成一个函数，输入一个二叉树，该函数输出它的镜像。
例如: 输入
     4
   /   \
  2     7
 / \   / \
1   3 6   9
镜像输出：
     4
   /   \
  7     2
 / \   / \
9   6 3   1

示例 1：
输入：root = [4,2,7,1,3,6,9]
输出：       [4,7,2,9,6,3,1]

时间复杂度 O(N)： 其中 N 为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点，占用 O(N) 时间。
空间复杂度 O(N)： 最差情况下（当二叉树退化为链表），递归时系统需使用 O(N) 大小的栈空间。
*/
class CMirrorBst {
    void swapNode(BstNode* node) {
        if ( !node || (!node->left && !node->right) ) return ;
        BstNode* temp = node->left;
        node->left = node->right;
        node->right = temp;
    }
public:

    BstNode* mirrorTree(BstNode* root) {
        {
            if ( !root )  return nullptr;
            auto tmp = root->left;
            root->left  = mirrorTree(root->right);
            root->right = mirrorTree(tmp);
            return root;
        }

{
        if ( !root || (!root->left && !root->right) ) return nullptr;
        swapNode(root);
        mirrorTree(root->left);
        mirrorTree(root->right);
        return root;
}
    }
    void Test_mirrorTree() {
        std::vector<int> vecData{4, 2, 7, 1, 3, 6, 9};
        CreateBstTree(vecData);
        // CreateBstTree();

std::cout << "before mirror ..." << std::endl;
        printInorder(g_pBstTree);
        std::cout << std::endl;

std::cout << "after mirror ..." << std::endl;
auto mirror = mirrorTree(g_pBstTree);
        printInorder(mirror);
        std::cout << std::endl;
    }
};
void tst_mirrorTree() {
    CMirrorBst cm;
    cm.Test_mirrorTree();
}

std::vector<int> rightSideView(TreeNode* root) {
    std::vector<int> res;
    if ( !root ) return res;

    std::queue<TreeNode*> que;
    que.push(root);
    while ( !que.empty() ) {
        size_t sz = que.size();
        for ( int i = 0; i < sz; i ++ ) {
            auto node = que.front();
            que.pop();
            if ( i == sz - 1 ) res.push_back( node->val );
            if (node->left ) que.push(node->left);
            if ( node->right )
                que.push(node->right);
        }
    }
    return res;
}

/*
    剑指 Offer 39. 数组中出现次数超过一半的数字
    数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。

    你可以假设数组是非空的，并且给定的数组总是存在多数元素。

    示例 1:
    输入: [1, 2, 3, 2, 2, 2, 5, 4, 2]
    输出: 2
*/
int MoreThanHalfNum_Solution(vector<int> numbers) {

        int n=1;
        int result=nums[0];

        for(int i=1;i<nums.size();i++){
            if(n==0){
                result=nums[i];
                n=1;
            }
            else if(result==nums[i])n++;
            else n--;
        }
        return result;

}

void lc_Entry() {

    tst_isPalindrome_str();
    return;
    tst_isPalindrome_int();
    return;

    tst_addTwoNumber();
    return;

    tst_bst_level_order(); return;


    tst_maxLength(); return;

    {
        // std::map < int, string > mapInfo;
        // mapInfo[ 13 ] = "bbc";
        // mapInfo[ 12 ] = "aaa";
        // mapInfo[ 11 ] = "ttc";
        // mapInfo[ 9 ] = "991";
        
        // for ( auto el : mapInfo ) {
        //     std::cout << el.first << " "  << el.second << std::endl;
        // }
        // return;
    }
    tst_lengthOfLongestSubstringEx(); return;

    
    tst_mirrorTree(); return;

    

    tst_isValidBst(); return;

    tst_buildTree(); return;
    tst_reverseAndCount(); return;


    tst_topKFrequent(); return;

    tst_KthBig(); return;

    tst_addStrings(); return;


    tst_unorder_set(); return;

    tst_hashTable();  return;

    tst_reverseInt(); return;

    tst_bst_operator();

    std::cout << "depth=" << GetDepthByBstTree( g_pBstTree ) << std::endl;
    std::cout << "count=" << GetKLevelNodesCount( g_pBstTree, 4 ) << std::endl;

    tst_twoSum_nosort(); return;

    tst_findDuplicate(); return;

    tst_searchInsert(); return;

    tst_bitCount(); return;
    tst_mystring(); return;

    tst_del_class_ptr(); return;

    tst_containsNearbyDuplicate(); return;
//    {
//        std::unordered_set<std::string> myset =
//        {"USA","Canada","France","UK","Japan","Germany","Italy"};

//        myset.erase ( myset.begin() );                    // erasing by iterator
////        myset.erase ( "France" );                         // erasing by key
//        myset.erase ( myset.find("France"), myset.end() ); // erasing by range

//        PrintInContainer(myset);
//        return;
//    }

    tst_maxSlidingWindow(); return;

    tst_findNumCount();return;

    tst_missingNum();return;

    tst_exchange(); return;

    tst_fib(); return;

    tst_isHappy(); return;

    tst_Power(); return;

    tst_minArray();return;

    tst_findPeakElement(); return;


    tst_binarySearch(); return;
//    std::cout << "g_sInts=" << g_sInts << std::endl;
//    return;
    tst_someClass(); return;

    tst_hasPathSum(); return;

    tst_minSubArrayLen(); return;


    tst_IsValidString(); return;

    tst_maxArea(); return;

    {
//        int myints[]={10,20,30,40,50,60,70};
//        std::vector<int> myvector (7);

//        std::copy_n( myints, 4, myvector.begin() );

//        std::cout << "myvector contains:";
//        for (std::vector<int>::iterator it = myvector.begin(); it!=myvector.end(); ++it)
//          std::cout << ' ' << *it;
//        std::cout << '\n';
//        return;
    }

//    std::vector<int> nums1 { 123, 91, 45, 5566, 9876 };
//    std::vector<int> tmp(nums1.size());
//    std::cout << "tmp size=" << tmp.size() << std::endl;
//    return;

    tst_insert_sort_2(); return;

    tst_merge_sort_2();  return;

    tst_heap_sort_1();   return;

    tst_vector();  return;

    tstsomeNode(); return;

    tstLingxingDerive(); return;

    Trie* next[26];
    std::cout << "sizeof(Trie)=" << array_size(next) << std::endl;
    return;

    Test_productExceptSelf(); return;

    Test_BstCodec(); return;

    Test_coinChange(); return;

    Test_C11Random(); return;

    Test_hanmingWeight(); return;
    
    Test_totalHammingDistance(); return;

    Test_sumOfLeftLeaves(); return;

    tst_binaryTreePaths(); return;

    Test_getNodesNum(); return;

    Test_invertTree(); return;

    Test_hanmingDistance(); return;

    CSortedListToBst sortl2bst;
    sortl2bst.TstEntry();
    return;

    TstList1(); return;

    // Test_KthLeastNumbers();

    std::vector<int> a{11, 23, 35, 47, 51, 53, 198, 2739, 31798};
    ListNode* retnode = ConstructList(a);
    PrintList(retnode);
    return;

    tstupper_bound(); return;
    {
        list<int> l1 = { 1, 2, 3, 4, 5 };
        list<int> l2 = { 6, 7, 8 };
        list<int>::iterator it;

        // iterator pointing to 1
        it = l1.begin();

        // advance the iterator by 2 positions
        printf("--- it=%d\n", *it);

        printf("--- l2 beg\n");
        advance(it, 2);
        printf("--- l2 end\n");
        printf("--- it=%d\n", *it);
        printf("\n"); //

        // transfer 3, 4 and 5 at the
        // beginning of l2
        l2.splice(l2.begin(), l2, it, l1.end());

        cout << "list l2 after splice operation" << endl;
        for (auto x : l2)
            cout << x << " ";

        cout << std::endl;

        printf("l1 beg\n");
        PrintInContainer(l1);//
        printf("l1 end\n");
        return;
    }
    {
        std::list < int > l1, l2;
        std::list < int >::iterator it;

        for ( int i = 0; i < 4; i ++ ) {
            l1.push_back(i+1);
        }
        for ( int i = 10; i <= 30; i += 10 ) {
            l2.push_back(i);
        }
        printf("--- l2 beg\n");
        PrintInContainer(l2);//  1 10 20 30 2 3 4
        printf("--- l2 end\n");
        printf("\n"); //

        it = l1.begin();
        ++ it;
        printf("it=%d\n", *it); // 2

        l1.splice(it, l2);

        PrintInContainer(l1);//  1 10 20 30 2 3 4
        printf("\n"); //

        printf("l2 beg\n");
        PrintInContainer(l2);//
        printf("l2 end\n");
        return;
    }

    {
        ObjA* oa = ObjA::GetInstance();
        oa->PrintSomeInfo();
        ObjA ot;
//        ObjA ov = ot;
        return ;
    }

    {
//        string home = "./logs";  //要先创建此目录,否则运行报错.
//        google::InitGoogleLogging("tstout");

//        string info_log = home + "master_info_";
//        info_log = home;
//        google::SetLogDestination(google::INFO, info_log.c_str());

//        string warning_log = home + "master_warning_";
//        warning_log = home;
//        google::SetLogDestination(google::WARNING, warning_log.c_str());

//        string error_log = home + "master_error_";
//        error_log = home;
//        google::SetLogDestination(google::ERROR, error_log.c_str());

//        string fatal_log = home + "master_fatal_";
//        fatal_log = home;
//        google::SetLogDestination(google::FATAL, fatal_log.c_str());

//        google::SetStderrLogging(google::GLOG_INFO);
        FLAGS_alsologtostderr = 1;

        // You can specify one of the following severity levels (in increasing order of severity)
        LOG(INFO) << "info";
        LOG(WARNING) << "warning";
        LOG(ERROR) << "error";
//        LOG(FATAL) << "fatal";   // Logging a FATAL message terminates the program (after the message is logged)!

//        return ;
    }

//    google::InitGoogleLogging("outlog");
//    google::SetLogDestination(google::GLOG_INFO, "loge");
//    google::SetStderrLogging(google::GLOG_WARNING);
//    google::SetStderrLogging(google::GLOG_INFO);
//    FLAGS_colorlogtostderr=true;

//    LOG(INFO) << "check tst";
//    google::InitGoogleLogging("outlog");
    for (int i = 0; i < 10; ++i) {
        LOG_IF(INFO, i > 5) << "LOG_IF i > 5 i:" << i;
        LOG_EVERY_N(INFO, 3) << "LOG_EVERY_N 3 i:" << i << " google::COUNTER:" << google::COUNTER;
        LOG_IF_EVERY_N(INFO, (i > 5), 2) << "LOG_IF_EVERY_N i > 5 2 i:" << i;
        LOG_FIRST_N(INFO, 4) << "LOG_FIRST_N 4 i:" << i << " google::COUNTER:" << google::COUNTER;
    }
    return;

    CheckIfBst chck;
    std::cout << "chck result=" << chck.IsValidBst_1(g_pBstTree) << std::endl;
    return;

    CheckHuiWen checkHuiwen;
    checkHuiwen.IsHuiWen();
    return;


    int i1 = 4;
    int i2 = 12;
    UNUSED(i2);
    int ret = i1 & (-i1) ;
    std::cout << "-i1=" << -i1 << std::endl;
    std::cout << "ret=" << ret << std::endl;
    return ;



    tst_1_lc();
}
